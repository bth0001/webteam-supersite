window["docxtemplater"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./es6/docxtemplater.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./es6/browser-versions/xmldom.js":
/*!****************************************!*\
  !*** ./es6/browser-versions/xmldom.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = window;\n\n//# sourceURL=webpack://docxtemplater/./es6/browser-versions/xmldom.js?");

/***/ }),

/***/ "./es6/doc-utils.js":
/*!**************************!*\
  !*** ./es6/doc-utils.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar _require = __webpack_require__(/*! xmldom */ \"./es6/browser-versions/xmldom.js\"),\n    DOMParser = _require.DOMParser,\n    XMLSerializer = _require.XMLSerializer;\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    throwXmlTagNotFound = _require2.throwXmlTagNotFound;\n\nfunction parser(tag) {\n\treturn _defineProperty({}, \"get\", function get(scope) {\n\t\tif (tag === \".\") {\n\t\t\treturn scope;\n\t\t}\n\t\treturn scope[tag];\n\t});\n}\n\nfunction endsWith(str, suffix) {\n\treturn str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n\treturn str.substring(0, prefix.length) === prefix;\n}\n\nfunction unique(arr) {\n\tvar hash = {},\n\t    result = [];\n\tfor (var i = 0, l = arr.length; i < l; ++i) {\n\t\tif (!hash.hasOwnProperty(arr[i])) {\n\t\t\thash[arr[i]] = true;\n\t\t\tresult.push(arr[i]);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction chunkBy(parsed, f) {\n\treturn parsed.reduce(function (chunks, p) {\n\t\tvar currentChunk = last(chunks);\n\t\tif (currentChunk.length === 0) {\n\t\t\tcurrentChunk.push(p);\n\t\t\treturn chunks;\n\t\t}\n\t\tvar res = f(p);\n\t\tif (res === \"start\") {\n\t\t\tchunks.push([p]);\n\t\t} else if (res === \"end\") {\n\t\t\tcurrentChunk.push(p);\n\t\t\tchunks.push([]);\n\t\t} else {\n\t\t\tcurrentChunk.push(p);\n\t\t}\n\t\treturn chunks;\n\t}, [[]]).filter(function (p) {\n\t\treturn p.length > 0;\n\t});\n}\n\nfunction last(a) {\n\treturn a[a.length - 1];\n}\n\nvar defaults = {\n\tnullGetter: function nullGetter(part) {\n\t\tif (!part.module) {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tif (part.module === \"rawxml\") {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn \"\";\n\t},\n\n\txmlFileNames: [],\n\tparser: parser,\n\tlinebreaks: false,\n\tdelimiters: {\n\t\tstart: \"{\",\n\t\tend: \"}\"\n\t}\n};\n\nfunction mergeObjects() {\n\tvar resObj = {};\n\tvar obj = void 0,\n\t    keys = void 0;\n\tfor (var i = 0; i < arguments.length; i += 1) {\n\t\tobj = arguments[i];\n\t\tkeys = Object.keys(obj);\n\t\tfor (var j = 0; j < keys.length; j += 1) {\n\t\t\tresObj[keys[j]] = obj[keys[j]];\n\t\t}\n\t}\n\treturn resObj;\n}\n\nfunction xml2str(xmlNode) {\n\tvar a = new XMLSerializer();\n\treturn a.serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\n\nfunction str2xml(str) {\n\tvar parser = new DOMParser();\n\treturn parser.parseFromString(str, \"text/xml\");\n}\n\nvar charMap = {\n\t\"&\": \"&amp;\",\n\t\"'\": \"&apos;\",\n\t\"<\": \"&lt;\",\n\t\">\": \"&gt;\",\n\t'\"': \"&quot;\"\n};\n\nvar regexStripRegexp = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\nfunction escapeRegExp(str) {\n\treturn str.replace(regexStripRegexp, \"\\\\$&\");\n}\n\nvar charMapRegexes = Object.keys(charMap).map(function (endChar) {\n\tvar startChar = charMap[endChar];\n\treturn {\n\t\trstart: new RegExp(escapeRegExp(startChar), \"g\"),\n\t\trend: new RegExp(escapeRegExp(endChar), \"g\"),\n\t\tstart: startChar,\n\t\tend: endChar\n\t};\n});\n\nfunction wordToUtf8(string) {\n\tvar r = void 0;\n\tfor (var i = 0, l = charMapRegexes.length; i < l; i++) {\n\t\tr = charMapRegexes[i];\n\t\tstring = string.replace(r.rstart, r.end);\n\t}\n\treturn string;\n}\n\nfunction utf8ToWord(string) {\n\tif (typeof string !== \"string\") {\n\t\tstring = string.toString();\n\t}\n\tvar r = void 0;\n\tfor (var i = 0, l = charMapRegexes.length; i < l; i++) {\n\t\tr = charMapRegexes[i];\n\t\tstring = string.replace(r.rend, r.start);\n\t}\n\treturn string;\n}\n\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n\tvar result = [];\n\tfor (var i = 0; i < arrays.length; i++) {\n\t\tvar array = arrays[i];\n\t\tfor (var j = 0, len = array.length; j < len; j++) {\n\t\t\tresult.push(array[j]);\n\t\t}\n\t}\n\treturn result;\n}\n\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n\treturn s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n\t/* regex is a string, content is the content. It returns an array of all matches with their offset, for example:\n \t regex=la\n \t content=lolalolilala\n returns: [{array: {0: 'la'},offset: 2},{array: {0: 'la'},offset: 8},{array: {0: 'la'} ,offset: 10}]\n */\n\tvar matchArray = [];\n\tvar match = void 0;\n\twhile ((match = regex.exec(content)) != null) {\n\t\tmatchArray.push({ array: match, offset: match.index });\n\t}\n\treturn matchArray;\n}\n\nfunction getRight(parsed, element, index) {\n\tfor (var i = index, l = parsed.length; i < l; i++) {\n\t\tvar part = parsed[i];\n\t\tif (part.value === \"</\" + element + \">\") {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrowXmlTagNotFound({ position: \"right\", element: element, parsed: parsed, index: index });\n}\n\nfunction getLeft(parsed, element, index) {\n\tfor (var i = index; i >= 0; i--) {\n\t\tvar part = parsed[i];\n\t\tif (part.value.indexOf(\"<\" + element) === 0 && [\">\", \" \"].indexOf(part.value[element.length + 1]) !== -1) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrowXmlTagNotFound({ position: \"left\", element: element, parsed: parsed, index: index });\n}\n\nfunction isTagStart(tagType, _ref2) {\n\tvar type = _ref2.type,\n\t    tag = _ref2.tag,\n\t    position = _ref2.position;\n\n\treturn type === \"tag\" && tag === tagType && position === \"start\";\n}\nfunction isTagEnd(tagType, _ref3) {\n\tvar type = _ref3.type,\n\t    tag = _ref3.tag,\n\t    position = _ref3.position;\n\n\treturn type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(options) {\n\treturn isTagStart(\"w:p\", options) || isTagStart(\"a:p\", options);\n}\nfunction isParagraphEnd(options) {\n\treturn isTagEnd(\"w:p\", options) || isTagEnd(\"a:p\", options);\n}\nfunction isTextStart(part) {\n\treturn part.type === \"tag\" && part.position === \"start\" && part.text;\n}\nfunction isTextEnd(part) {\n\treturn part.type === \"tag\" && part.position === \"end\" && part.text;\n}\n\nfunction isContent(p) {\n\treturn p.type === \"placeholder\" || p.type === \"content\" && p.position === \"insidetag\";\n}\n\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/;\n// 00    NUL '\\0' (null character)\n// 01    SOH (start of heading)\n// 02    STX (start of text)\n// 03    ETX (end of text)\n// 04    EOT (end of transmission)\n// 05    ENQ (enquiry)\n// 06    ACK (acknowledge)\n// 07    BEL '\\a' (bell)\n// 08    BS  '\\b' (backspace)\n// 0B    VT  '\\v' (vertical tab)\n// 0C    FF  '\\f' (form feed)\n// 0E    SO  (shift out)\n// 0F    SI  (shift in)\n// 10    DLE (data link escape)\n// 11    DC1 (device control 1)\n// 12    DC2 (device control 2)\n// 13    DC3 (device control 3)\n// 14    DC4 (device control 4)\n// 15    NAK (negative ack.)\n// 16    SYN (synchronous idle)\n// 17    ETB (end of trans. blk)\n// 18    CAN (cancel)\n// 19    EM  (end of medium)\n// 1A    SUB (substitute)\n// 1B    ESC (escape)\n// 1C    FS  (file separator)\n// 1D    GS  (group separator)\n// 1E    RS  (record separator)\n// 1F    US  (unit separator)\nfunction hasCorruptCharacters(string) {\n\treturn corruptCharacters.test(string);\n}\n\nmodule.exports = {\n\tendsWith: endsWith,\n\tstartsWith: startsWith,\n\tisContent: isContent,\n\tisParagraphStart: isParagraphStart,\n\tisParagraphEnd: isParagraphEnd,\n\tisTagStart: isTagStart,\n\tisTagEnd: isTagEnd,\n\tisTextStart: isTextStart,\n\tisTextEnd: isTextEnd,\n\tunique: unique,\n\tchunkBy: chunkBy,\n\tlast: last,\n\tmergeObjects: mergeObjects,\n\txml2str: xml2str,\n\tstr2xml: str2xml,\n\tgetRight: getRight,\n\tgetLeft: getLeft,\n\tpregMatchAll: pregMatchAll,\n\tconvertSpaces: convertSpaces,\n\tescapeRegExp: escapeRegExp,\n\tcharMapRegexes: charMapRegexes,\n\thasCorruptCharacters: hasCorruptCharacters,\n\tdefaults: defaults,\n\twordToUtf8: wordToUtf8,\n\tutf8ToWord: utf8ToWord,\n\tconcatArrays: concatArrays,\n\tcharMap: charMap\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/doc-utils.js?");

/***/ }),

/***/ "./es6/docxtemplater.js":
/*!******************************!*\
  !*** ./es6/docxtemplater.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DocUtils = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\");\nDocUtils.traits = __webpack_require__(/*! ./traits */ \"./es6/traits.js\");\nDocUtils.moduleWrapper = __webpack_require__(/*! ./module-wrapper */ \"./es6/module-wrapper.js\");\nvar defaults = DocUtils.defaults,\n    str2xml = DocUtils.str2xml,\n    xml2str = DocUtils.xml2str,\n    moduleWrapper = DocUtils.moduleWrapper,\n    utf8ToWord = DocUtils.utf8ToWord,\n    concatArrays = DocUtils.concatArrays,\n    unique = DocUtils.unique;\n\nvar _require = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    XTInternalError = _require.XTInternalError,\n    throwFileTypeNotIdentified = _require.throwFileTypeNotIdentified,\n    throwFileTypeNotHandled = _require.throwFileTypeNotHandled,\n    throwApiVersionError = _require.throwApiVersionError;\n\nvar currentModuleApiVersion = [3, 6, 0];\n\nvar Docxtemplater = function () {\n\tfunction Docxtemplater() {\n\t\t_classCallCheck(this, Docxtemplater);\n\n\t\tif (arguments.length > 0) {\n\t\t\tthrow new Error(\"The constructor with parameters has been removed in docxtemplater 3, please check the upgrade guide.\");\n\t\t}\n\t\tthis.compiled = {};\n\t\tthis.modules = [];\n\t\tthis.setOptions({});\n\t}\n\n\t_createClass(Docxtemplater, [{\n\t\tkey: \"getModuleApiVersion\",\n\t\tvalue: function getModuleApiVersion() {\n\t\t\treturn currentModuleApiVersion.join(\".\");\n\t\t}\n\t}, {\n\t\tkey: \"verifyApiVersion\",\n\t\tvalue: function verifyApiVersion(neededVersion) {\n\t\t\tneededVersion = neededVersion.split(\".\").map(function (i) {\n\t\t\t\treturn parseInt(i, 10);\n\t\t\t});\n\t\t\tif (neededVersion.length !== 3) {\n\t\t\t\tthrowApiVersionError(\"neededVersion is not a valid version\", {\n\t\t\t\t\tneededVersion: neededVersion,\n\t\t\t\t\texplanation: \"the neededVersion must be an array of length 3\"\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (neededVersion[0] !== currentModuleApiVersion[0]) {\n\t\t\t\tthrowApiVersionError(\"The major api version do not match\", {\n\t\t\t\t\tneededVersion: neededVersion,\n\t\t\t\t\tcurrentModuleApiVersion: currentModuleApiVersion,\n\t\t\t\t\texplanation: \"moduleAPIVersionMismatch : needed=\" + neededVersion.join(\".\") + \", current=\" + currentModuleApiVersion.join(\".\")\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (neededVersion[1] > currentModuleApiVersion[1]) {\n\t\t\t\tthrowApiVersionError(\"The minor api version is not uptodate\", {\n\t\t\t\t\tneededVersion: neededVersion,\n\t\t\t\t\tcurrentModuleApiVersion: currentModuleApiVersion,\n\t\t\t\t\texplanation: \"moduleAPIVersionMismatch : needed=\" + neededVersion.join(\".\") + \", current=\" + currentModuleApiVersion.join(\".\")\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: \"setModules\",\n\t\tvalue: function setModules(obj) {\n\t\t\tthis.modules.forEach(function (module) {\n\t\t\t\tmodule.set(obj);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"sendEvent\",\n\t\tvalue: function sendEvent(eventName) {\n\t\t\tthis.modules.forEach(function (module) {\n\t\t\t\tmodule.on(eventName);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"attachModule\",\n\t\tvalue: function attachModule(module) {\n\t\t\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\t\tvar prefix = options.prefix;\n\n\t\t\tif (prefix) {\n\t\t\t\tmodule.prefix = prefix;\n\t\t\t}\n\t\t\tthis.modules.push(moduleWrapper(module));\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"setOptions\",\n\t\tvalue: function setOptions(options) {\n\t\t\tvar _this = this;\n\n\t\t\tif (options.delimiters) {\n\t\t\t\toptions.delimiters.start = utf8ToWord(options.delimiters.start);\n\t\t\t\toptions.delimiters.end = utf8ToWord(options.delimiters.end);\n\t\t\t}\n\t\t\tthis.options = options;\n\t\t\tObject.keys(defaults).forEach(function (key) {\n\t\t\t\tvar defaultValue = defaults[key];\n\t\t\t\t_this.options[key] = _this.options[key] != null ? _this.options[key] : defaultValue;\n\t\t\t\t_this[key] = _this.options[key];\n\t\t\t});\n\t\t\tif (this.zip) {\n\t\t\t\tthis.updateFileTypeConfig();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"loadZip\",\n\t\tvalue: function loadZip(zip) {\n\t\t\tif (zip.loadAsync) {\n\t\t\t\tthrow new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, see changelog\");\n\t\t\t}\n\t\t\tthis.zip = zip;\n\t\t\tthis.updateFileTypeConfig();\n\n\t\t\tthis.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n\t\t\t\treturn moduleFunction();\n\t\t\t}), this.modules]);\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"compileFile\",\n\t\tvalue: function compileFile(fileName) {\n\t\t\tvar currentFile = this.createTemplateClass(fileName);\n\t\t\tcurrentFile.parse();\n\t\t\tthis.compiled[fileName] = currentFile;\n\t\t}\n\t}, {\n\t\tkey: \"resolveData\",\n\t\tvalue: function resolveData(data) {\n\t\t\tvar _this2 = this;\n\n\t\t\treturn Promise.all(Object.keys(this.compiled).map(function (from) {\n\t\t\t\tvar currentFile = _this2.compiled[from];\n\t\t\t\treturn currentFile.resolveTags(data);\n\t\t\t})).then(function (resolved) {\n\t\t\t\treturn concatArrays(resolved);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"compile\",\n\t\tvalue: function compile() {\n\t\t\tvar _this3 = this;\n\n\t\t\tif (Object.keys(this.compiled).length) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis.options = this.modules.reduce(function (options, module) {\n\t\t\t\treturn module.optionsTransformer(options, _this3);\n\t\t\t}, this.options);\n\t\t\tthis.options.xmlFileNames = unique(this.options.xmlFileNames);\n\t\t\tthis.xmlDocuments = this.options.xmlFileNames.reduce(function (xmlDocuments, fileName) {\n\t\t\t\tvar content = _this3.zip.files[fileName].asText();\n\t\t\t\txmlDocuments[fileName] = str2xml(content);\n\t\t\t\treturn xmlDocuments;\n\t\t\t}, {});\n\t\t\tthis.setModules({\n\t\t\t\tzip: this.zip,\n\t\t\t\txmlDocuments: this.xmlDocuments\n\t\t\t});\n\t\t\tthis.getTemplatedFiles();\n\t\t\tthis.setModules({ compiled: this.compiled });\n\t\t\t// Loop inside all templatedFiles (ie xml files with content).\n\t\t\t// Sometimes they don't exist (footer.xml for example)\n\t\t\tthis.templatedFiles.forEach(function (fileName) {\n\t\t\t\tif (_this3.zip.files[fileName] != null) {\n\t\t\t\t\t_this3.compileFile(fileName);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"updateFileTypeConfig\",\n\t\tvalue: function updateFileTypeConfig() {\n\t\t\tvar fileType = void 0;\n\t\t\tif (this.zip.files.mimetype) {\n\t\t\t\tfileType = \"odt\";\n\t\t\t}\n\t\t\tif (this.zip.files[\"word/document.xml\"] || this.zip.files[\"word/document2.xml\"]) {\n\t\t\t\tfileType = \"docx\";\n\t\t\t}\n\t\t\tif (this.zip.files[\"ppt/presentation.xml\"]) {\n\t\t\t\tfileType = \"pptx\";\n\t\t\t}\n\n\t\t\tif (fileType === \"odt\") {\n\t\t\t\tthrowFileTypeNotHandled(fileType);\n\t\t\t}\n\t\t\tif (!fileType) {\n\t\t\t\tthrowFileTypeNotIdentified();\n\t\t\t}\n\t\t\tthis.fileType = fileType;\n\t\t\tthis.fileTypeConfig = this.options.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType];\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render() {\n\t\t\tvar _this4 = this;\n\n\t\t\tthis.compile();\n\t\t\tthis.setModules({\n\t\t\t\tdata: this.data\n\t\t\t});\n\t\t\tthis.mapper = this.modules.reduce(function (value, module) {\n\t\t\t\treturn module.getRenderedMap(value);\n\t\t\t}, {});\n\n\t\t\tthis.fileTypeConfig.tagsXmlLexedArray = unique(this.fileTypeConfig.tagsXmlLexedArray);\n\t\t\tthis.fileTypeConfig.tagsXmlTextArray = unique(this.fileTypeConfig.tagsXmlTextArray);\n\n\t\t\tObject.keys(this.mapper).forEach(function (to) {\n\t\t\t\tvar _mapper$to = _this4.mapper[to],\n\t\t\t\t    from = _mapper$to.from,\n\t\t\t\t    data = _mapper$to.data;\n\n\t\t\t\tvar currentFile = _this4.compiled[from];\n\t\t\t\tcurrentFile.setTags(data);\n\t\t\t\tcurrentFile.render(to);\n\t\t\t\t_this4.zip.file(to, currentFile.content, { createFolders: true });\n\t\t\t});\n\t\t\tthis.sendEvent(\"syncing-zip\");\n\t\t\tthis.syncZip();\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"syncZip\",\n\t\tvalue: function syncZip() {\n\t\t\tvar _this5 = this;\n\n\t\t\tObject.keys(this.xmlDocuments).forEach(function (fileName) {\n\t\t\t\t_this5.zip.remove(fileName);\n\t\t\t\tvar content = xml2str(_this5.xmlDocuments[fileName]);\n\t\t\t\treturn _this5.zip.file(fileName, content, { createFolders: true });\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"setData\",\n\t\tvalue: function setData(data) {\n\t\t\tthis.data = data;\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"getZip\",\n\t\tvalue: function getZip() {\n\t\t\treturn this.zip;\n\t\t}\n\t}, {\n\t\tkey: \"createTemplateClass\",\n\t\tvalue: function createTemplateClass(path) {\n\t\t\tvar usedData = this.zip.files[path].asText();\n\t\t\treturn this.createTemplateClassFromContent(usedData, path);\n\t\t}\n\t}, {\n\t\tkey: \"createTemplateClassFromContent\",\n\t\tvalue: function createTemplateClassFromContent(content, filePath) {\n\t\t\tvar _this6 = this;\n\n\t\t\tvar xmltOptions = {\n\t\t\t\tfilePath: filePath\n\t\t\t};\n\t\t\tObject.keys(defaults).forEach(function (key) {\n\t\t\t\txmltOptions[key] = _this6[key];\n\t\t\t});\n\t\t\txmltOptions.fileTypeConfig = this.fileTypeConfig;\n\t\t\txmltOptions.modules = this.modules;\n\t\t\treturn new Docxtemplater.XmlTemplater(content, xmltOptions);\n\t\t}\n\t}, {\n\t\tkey: \"getFullText\",\n\t\tvalue: function getFullText(path) {\n\t\t\treturn this.createTemplateClass(path || this.fileTypeConfig.textPath(this.zip)).getFullText();\n\t\t}\n\t}, {\n\t\tkey: \"getTemplatedFiles\",\n\t\tvalue: function getTemplatedFiles() {\n\t\t\tthis.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n\t\t\treturn this.templatedFiles;\n\t\t}\n\t}]);\n\n\treturn Docxtemplater;\n}();\n\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors */ \"./es6/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater */ \"./es6/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config */ \"./es6/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher */ \"./es6/xml-matcher.js\");\nmodule.exports = Docxtemplater;\n\n//# sourceURL=webpack://docxtemplater/./es6/docxtemplater.js?");

/***/ }),

/***/ "./es6/errors.js":
/*!***********************!*\
  !*** ./es6/errors.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction first(a) {\n\treturn a[0];\n}\nfunction last(a) {\n\treturn a[a.length - 1];\n}\nfunction XTError(message) {\n\tthis.name = \"GenericError\";\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\n\nfunction XTTemplateError(message) {\n\tthis.name = \"TemplateError\";\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\n\nfunction RenderingError(message) {\n\tthis.name = \"RenderingError\";\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nRenderingError.prototype = new XTError();\n\nfunction XTScopeParserError(message) {\n\tthis.name = \"ScopeParserError\";\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\n\nfunction XTInternalError(message) {\n\tthis.name = \"InternalError\";\n\tthis.properties = { explanation: \"InternalError\" };\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\n\nfunction XTAPIVersionError(message) {\n\tthis.name = \"APIVersionError\";\n\tthis.properties = { explanation: \"APIVersionError\" };\n\tthis.message = message;\n\tthis.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\n\nfunction throwApiVersionError(msg, properties) {\n\tvar err = new XTAPIVersionError(msg);\n\terr.properties = _extends({\n\t\tid: \"api_version_error\"\n\t}, properties);\n\tthrow err;\n}\n\nfunction throwMultiError(errors) {\n\tvar err = new XTTemplateError(\"Multi error\");\n\terr.properties = {\n\t\terrors: errors,\n\t\tid: \"multi_error\",\n\t\texplanation: \"The template has multiple errors\"\n\t};\n\tthrow err;\n}\n\nfunction getUnopenedTagException(options) {\n\tvar err = new XTTemplateError(\"Unopened tag\");\n\terr.properties = {\n\t\txtag: last(options.xtag.split(\" \")),\n\t\tid: \"unopened_tag\",\n\t\tcontext: options.xtag,\n\t\toffset: options.offset,\n\t\tlIndex: options.lIndex,\n\t\texplanation: \"The tag beginning with \\\"\" + options.xtag.substr(0, 10) + \"\\\" is unopened\"\n\t};\n\treturn err;\n}\n\nfunction getUnclosedTagException(options) {\n\tvar err = new XTTemplateError(\"Unclosed tag\");\n\terr.properties = {\n\t\txtag: first(options.xtag.split(\" \")).substr(1),\n\t\tid: \"unclosed_tag\",\n\t\tcontext: options.xtag,\n\t\toffset: options.offset,\n\t\tlIndex: options.lIndex,\n\t\texplanation: \"The tag beginning with \\\"\" + options.xtag.substr(0, 10) + \"\\\" is unclosed\"\n\t};\n\treturn err;\n}\n\nfunction throwXmlTagNotFound(options) {\n\tvar err = new XTTemplateError(\"No tag \\\"\" + options.element + \"\\\" was found at the \" + options.position);\n\terr.properties = {\n\t\tid: \"no_xml_tag_found_at_\" + options.position,\n\t\texplanation: \"No tag \\\"\" + options.element + \"\\\" was found at the \" + options.position,\n\t\tpart: options.parsed[options.index],\n\t\tparsed: options.parsed,\n\t\tindex: options.index,\n\t\telement: options.element\n\t};\n\tthrow err;\n}\n\nfunction throwCorruptCharacters(_ref) {\n\tvar tag = _ref.tag,\n\t    value = _ref.value;\n\n\tvar err = new RenderingError(\"There are some XML corrupt characters\");\n\terr.properties = {\n\t\tid: \"invalid_xml_characters\",\n\t\txtag: tag,\n\t\tvalue: value,\n\t\texplanation: \"There are some corrupt characters for the field ${tag}\"\n\t};\n\tthrow err;\n}\n\nfunction throwContentMustBeString(type) {\n\tvar err = new XTInternalError(\"Content must be a string\");\n\terr.properties.id = \"xmltemplater_content_must_be_string\";\n\terr.properties.type = type;\n\tthrow err;\n}\n\nfunction throwRawTagNotInParagraph(options) {\n\tvar err = new XTTemplateError(\"Raw tag not in paragraph\");\n\tvar _options$part = options.part,\n\t    value = _options$part.value,\n\t    offset = _options$part.offset;\n\n\terr.properties = {\n\t\tid: \"raw_tag_outerxml_invalid\",\n\t\texplanation: \"The tag \\\"\" + value + \"\\\" is not inside a paragraph\",\n\t\trootError: options.rootError,\n\t\txtag: value,\n\t\toffset: offset,\n\t\tpostparsed: options.postparsed,\n\t\texpandTo: options.expandTo,\n\t\tindex: options.index\n\t};\n\tthrow err;\n}\n\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n\tvar err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n\tvar tag = options.part.value;\n\terr.properties = {\n\t\tid: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n\t\texplanation: \"The raw tag \\\"\" + tag + \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\",\n\t\txtag: tag,\n\t\toffset: options.part.offset,\n\t\tparagraphParts: options.paragraphParts\n\t};\n\tthrow err;\n}\n\nfunction getUnmatchedLoopException(options) {\n\tvar location = options.location;\n\n\tvar t = location === \"start\" ? \"unclosed\" : \"unopened\";\n\tvar T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n\n\tvar err = new XTTemplateError(T + \" loop\");\n\tvar tag = options.part.value;\n\terr.properties = {\n\t\tid: t + \"_loop\",\n\t\texplanation: \"The loop with tag \\\"\" + tag + \"\\\" is \" + t,\n\t\txtag: tag\n\t};\n\treturn err;\n}\n\nfunction getClosingTagNotMatchOpeningTag(options) {\n\tvar tags = options.tags;\n\n\n\tvar err = new XTTemplateError(\"Closing tag does not match opening tag\");\n\terr.properties = {\n\t\tid: \"closing_tag_does_not_match_opening_tag\",\n\t\texplanation: \"The tag \\\"\" + tags[0].value + \"\\\" is closed by the tag \\\"\" + tags[1].value + \"\\\"\",\n\t\topeningtag: tags[0].value,\n\t\toffset: [tags[0].offset, tags[1].offset],\n\t\tclosingtag: tags[1].value\n\t};\n\treturn err;\n}\n\nfunction getScopeCompilationError(_ref2) {\n\tvar tag = _ref2.tag,\n\t    rootError = _ref2.rootError;\n\n\tvar err = new XTScopeParserError(\"Scope parser compilation failed\");\n\terr.properties = {\n\t\tid: \"scopeparser_compilation_failed\",\n\t\ttag: tag,\n\t\texplanation: \"The scope parser for the tag \\\"\" + tag + \"\\\" failed to compile\",\n\t\trootError: rootError\n\t};\n\treturn err;\n}\n\nfunction getScopeParserExecutionError(_ref3) {\n\tvar tag = _ref3.tag,\n\t    scope = _ref3.scope,\n\t    error = _ref3.error;\n\n\tvar err = new XTScopeParserError(\"Scope parser execution failed\");\n\terr.properties = {\n\t\tid: \"scopeparser_execution_failed\",\n\t\texplanation: \"The scope parser for the tag \" + tag + \" failed to execute\",\n\t\tscope: scope,\n\t\ttag: tag,\n\t\trootError: error\n\t};\n\treturn err;\n}\n\nfunction getLoopPositionProducesInvalidXMLError(_ref4) {\n\tvar tag = _ref4.tag;\n\n\tvar err = new XTTemplateError(\"The position of the loop tags \\\"\" + tag + \"\\\" would produce invalid XML\");\n\terr.properties = {\n\t\ttag: tag,\n\t\tid: \"loop_position_invalid\",\n\t\texplanation: \"The tags \\\"\" + tag + \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"\n\t};\n\treturn err;\n}\n\nfunction throwUnimplementedTagType(part) {\n\tvar err = new XTTemplateError(\"Unimplemented tag type \\\"\" + part.type + \"\\\"\");\n\terr.properties = {\n\t\tpart: part,\n\t\tid: \"unimplemented_tag_type\"\n\t};\n\tthrow err;\n}\n\nfunction throwMalformedXml(part) {\n\tvar err = new XTInternalError(\"Malformed xml\");\n\terr.properties = {\n\t\tpart: part,\n\t\tid: \"malformed_xml\"\n\t};\n\tthrow err;\n}\n\nfunction throwLocationInvalid(part) {\n\tthrow new XTInternalError(\"Location should be one of \\\"start\\\" or \\\"end\\\" (given : \" + part.location + \")\");\n}\n\nfunction throwFileTypeNotHandled(fileType) {\n\tvar err = new XTInternalError(\"The filetype \\\"\" + fileType + \"\\\" is not handled by docxtemplater\");\n\terr.properties = {\n\t\tid: \"filetype_not_handled\",\n\t\texplanation: \"The file you are trying to generate is of type \\\"\" + fileType + \"\\\", but only docx and pptx formats are handled\",\n\t\tfileType: fileType\n\t};\n\tthrow err;\n}\n\nfunction throwFileTypeNotIdentified() {\n\tvar err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ?\");\n\terr.properties = {\n\t\tid: \"filetype_not_identified\"\n\t};\n\tthrow err;\n}\n\nfunction throwXmlInvalid(content, offset) {\n\tvar err = new XTTemplateError(\"An XML file has invalid xml\");\n\terr.properties = {\n\t\tid: \"file_has_invalid_xml\",\n\t\tcontent: content,\n\t\toffset: offset,\n\t\texplanation: \"The docx contains invalid XML, it is most likely corrupt\"\n\t};\n\tthrow err;\n}\n\nmodule.exports = {\n\tXTError: XTError,\n\tXTTemplateError: XTTemplateError,\n\tXTInternalError: XTInternalError,\n\tXTScopeParserError: XTScopeParserError,\n\tXTAPIVersionError: XTAPIVersionError,\n\tRenderingError: RenderingError,\n\n\tgetClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n\tgetLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n\tgetScopeCompilationError: getScopeCompilationError,\n\tgetScopeParserExecutionError: getScopeParserExecutionError,\n\tgetUnclosedTagException: getUnclosedTagException,\n\tgetUnmatchedLoopException: getUnmatchedLoopException,\n\tgetUnopenedTagException: getUnopenedTagException,\n\n\tthrowApiVersionError: throwApiVersionError,\n\tthrowContentMustBeString: throwContentMustBeString,\n\tthrowCorruptCharacters: throwCorruptCharacters,\n\tthrowFileTypeNotHandled: throwFileTypeNotHandled,\n\tthrowFileTypeNotIdentified: throwFileTypeNotIdentified,\n\tthrowLocationInvalid: throwLocationInvalid,\n\tthrowMalformedXml: throwMalformedXml,\n\tthrowMultiError: throwMultiError,\n\tthrowRawTagNotInParagraph: throwRawTagNotInParagraph,\n\tthrowRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n\tthrowUnimplementedTagType: throwUnimplementedTagType,\n\tthrowXmlTagNotFound: throwXmlTagNotFound,\n\tthrowXmlInvalid: throwXmlInvalid\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/errors.js?");

/***/ }),

/***/ "./es6/file-type-config.js":
/*!*********************************!*\
  !*** ./es6/file-type-config.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar loopModule = __webpack_require__(/*! ./modules/loop */ \"./es6/modules/loop.js\");\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve */ \"./es6/modules/space-preserve.js\");\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml */ \"./es6/modules/rawxml.js\");\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait */ \"./es6/modules/expand-pair-trait.js\");\nvar render = __webpack_require__(/*! ./modules/render */ \"./es6/modules/render.js\");\n\nvar PptXFileTypeConfig = {\n\tgetTemplatedFiles: function getTemplatedFiles(zip) {\n\t\tvar slideTemplates = zip.file(/ppt\\/(slides|slideMasters)\\/(slide|slideMaster)\\d+\\.xml/).map(function (file) {\n\t\t\treturn file.name;\n\t\t});\n\t\treturn slideTemplates.concat([\"ppt/presentation.xml\", \"docProps/app.xml\", \"docProps/core.xml\"]);\n\t},\n\ttextPath: function textPath() {\n\t\treturn \"ppt/slides/slide1.xml\";\n\t},\n\n\ttagsXmlTextArray: [\"a:t\", \"m:t\", \"vt:lpstr\", \"dc:title\", \"dc:creator\", \"cp:keywords\"],\n\ttagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:table\", \"a:p\", \"a:r\", \"a:rPr\"],\n\texpandTags: [{ contains: \"a:tc\", expand: \"a:tr\" }],\n\tonParagraphLoop: [{ contains: \"a:p\", expand: \"a:p\", onlyTextInTag: true }],\n\ttagRawXml: \"p:sp\",\n\ttagTextXml: \"a:t\",\n\tbaseModules: [loopModule, expandPairTrait, rawXmlModule, render]\n};\n\nvar DocXFileTypeConfig = {\n\tgetTemplatedFiles: function getTemplatedFiles(zip) {\n\t\tvar baseTags = [\"docProps/core.xml\", \"docProps/app.xml\", \"word/document.xml\", \"word/document2.xml\"];\n\t\tvar slideTemplates = zip.file(/word\\/(header|footer)\\d+\\.xml/).map(function (file) {\n\t\t\treturn file.name;\n\t\t});\n\t\treturn slideTemplates.concat(baseTags);\n\t},\n\ttextPath: function textPath(zip) {\n\t\tif (zip.files[\"word/document.xml\"]) {\n\t\t\treturn \"word/document.xml\";\n\t\t}\n\t\tif (zip.files[\"word/document2.xml\"]) {\n\t\t\treturn \"word/document2.xml\";\n\t\t}\n\t},\n\n\ttagsXmlTextArray: [\"w:t\", \"m:t\", \"vt:lpstr\", \"dc:title\", \"dc:creator\", \"cp:keywords\"],\n\ttagsXmlLexedArray: [\"w:tc\", \"w:tr\", \"w:table\", \"w:p\", \"w:r\", \"w:rPr\", \"w:pPr\", \"w:spacing\"],\n\texpandTags: [{ contains: \"w:tc\", expand: \"w:tr\" }],\n\tonParagraphLoop: [{ contains: \"w:p\", expand: \"w:p\", onlyTextInTag: true }],\n\ttagRawXml: \"w:p\",\n\ttagTextXml: \"w:t\",\n\tbaseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render]\n};\n\nmodule.exports = {\n\tdocx: DocXFileTypeConfig,\n\tpptx: PptXFileTypeConfig\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/file-type-config.js?");

/***/ }),

/***/ "./es6/lexer.js":
/*!**********************!*\
  !*** ./es6/lexer.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _require = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    getUnclosedTagException = _require.getUnclosedTagException,\n    getUnopenedTagException = _require.getUnopenedTagException,\n    throwMalformedXml = _require.throwMalformedXml,\n    throwXmlInvalid = _require.throwXmlInvalid;\n\nvar _require2 = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    concatArrays = _require2.concatArrays,\n    isTextStart = _require2.isTextStart,\n    isTextEnd = _require2.isTextEnd;\n\nvar EQUAL = 0;\nvar START = -1;\nvar END = 1;\n\nfunction inRange(range, match) {\n\treturn range[0] <= match.offset && match.offset < range[1];\n}\n\nfunction updateInTextTag(part, inTextTag) {\n\tif (isTextStart(part)) {\n\t\tif (inTextTag) {\n\t\t\tthrowMalformedXml(part);\n\t\t}\n\t\treturn true;\n\t}\n\tif (isTextEnd(part)) {\n\t\tif (!inTextTag) {\n\t\t\tthrowMalformedXml(part);\n\t\t}\n\t\treturn false;\n\t}\n\treturn inTextTag;\n}\n\nfunction getTag(tag) {\n\tvar position = \"start\";\n\tvar start = 1;\n\tif (tag[tag.length - 2] === \"/\") {\n\t\tposition = \"selfclosing\";\n\t}\n\tif (tag[1] === \"/\") {\n\t\tstart = 2;\n\t\tposition = \"end\";\n\t}\n\tvar index = tag.indexOf(\" \");\n\tvar end = index === -1 ? tag.length - 1 : index;\n\treturn {\n\t\ttag: tag.slice(start, end),\n\t\tposition: position\n\t};\n}\n\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n\tvar cursor = 0;\n\tvar contentLength = content.length;\n\tvar allMatches = concatArrays([textMatchArray.map(function (tag) {\n\t\treturn { tag: tag, text: true };\n\t}), othersMatchArray.map(function (tag) {\n\t\treturn { tag: tag, text: false };\n\t})]).reduce(function (allMatches, t) {\n\t\tallMatches[t.tag] = t.text;\n\t\treturn allMatches;\n\t}, {});\n\tvar totalMatches = [];\n\n\twhile (cursor < contentLength) {\n\t\tcursor = content.indexOf(\"<\", cursor);\n\t\tif (cursor === -1) {\n\t\t\tbreak;\n\t\t}\n\t\tvar offset = cursor;\n\t\tvar nextOpening = content.indexOf(\"<\", cursor + 1);\n\t\tcursor = content.indexOf(\">\", cursor);\n\t\tif (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n\t\t\tthrowXmlInvalid(content, offset);\n\t\t}\n\t\tvar tagText = content.slice(offset, cursor + 1);\n\n\t\tvar _getTag = getTag(tagText),\n\t\t    tag = _getTag.tag,\n\t\t    position = _getTag.position;\n\n\t\tvar text = allMatches[tag];\n\t\tif (text == null) {\n\t\t\tcontinue;\n\t\t}\n\t\ttotalMatches.push({\n\t\t\ttype: \"tag\",\n\t\t\tposition: position,\n\t\t\ttext: text,\n\t\t\toffset: offset,\n\t\t\tvalue: tagText,\n\t\t\ttag: tag\n\t\t});\n\t}\n\n\treturn totalMatches;\n}\n\nfunction getDelimiterErrors(delimiterMatches, fullText, ranges) {\n\tif (delimiterMatches.length === 0) {\n\t\treturn [];\n\t}\n\tvar errors = [];\n\tvar inDelimiter = false;\n\tvar lastDelimiterMatch = { offset: 0 };\n\tvar xtag = void 0;\n\tvar rangeIndex = 0;\n\tdelimiterMatches.forEach(function (delimiterMatch) {\n\t\twhile (ranges[rangeIndex + 1]) {\n\t\t\tif (ranges[rangeIndex + 1].offset > delimiterMatch.offset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trangeIndex++;\n\t\t}\n\t\txtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n\t\tif (delimiterMatch.position === \"start\" && inDelimiter || delimiterMatch.position === \"end\" && !inDelimiter) {\n\t\t\tif (delimiterMatch.position === \"start\") {\n\t\t\t\terrors.push(getUnclosedTagException({ xtag: xtag, offset: lastDelimiterMatch.offset }));\n\t\t\t\tdelimiterMatch.error = true;\n\t\t\t} else {\n\t\t\t\terrors.push(getUnopenedTagException({ xtag: xtag, offset: delimiterMatch.offset }));\n\t\t\t\tdelimiterMatch.error = true;\n\t\t\t}\n\t\t} else {\n\t\t\tinDelimiter = !inDelimiter;\n\t\t}\n\t\tlastDelimiterMatch = delimiterMatch;\n\t});\n\tvar delimiterMatch = { offset: fullText.length };\n\txtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n\tif (inDelimiter) {\n\t\terrors.push(getUnclosedTagException({ xtag: xtag, offset: lastDelimiterMatch.offset }));\n\t\tdelimiterMatch.error = true;\n\t}\n\treturn errors;\n}\n\nfunction compareOffsets(startOffset, endOffset) {\n\tif (startOffset === endOffset) {\n\t\treturn EQUAL;\n\t}\n\tif (startOffset === -1 || endOffset === -1) {\n\t\treturn endOffset < startOffset ? START : END;\n\t}\n\treturn startOffset < endOffset ? START : END;\n}\n\nfunction splitDelimiters(inside) {\n\tvar newDelimiters = inside.split(\" \");\n\tif (newDelimiters.length !== 2) {\n\t\tthrow new Error(\"New Delimiters cannot be parsed\");\n\t}\n\n\tvar _newDelimiters = _slicedToArray(newDelimiters, 2),\n\t    start = _newDelimiters[0],\n\t    end = _newDelimiters[1];\n\n\tif (start.length === 0 || end.length === 0) {\n\t\tthrow new Error(\"New Delimiters cannot be parsed\");\n\t}\n\treturn [start, end];\n}\n\nfunction getAllIndexes(fullText, delimiters) {\n\tvar indexes = [];\n\tvar start = delimiters.start,\n\t    end = delimiters.end;\n\n\tvar offset = -1;\n\twhile (true) {\n\t\tvar startOffset = fullText.indexOf(start, offset + 1);\n\t\tvar endOffset = fullText.indexOf(end, offset + 1);\n\t\tvar position = null;\n\t\tvar len = void 0;\n\t\tvar compareResult = compareOffsets(startOffset, endOffset);\n\t\tif (compareResult === EQUAL) {\n\t\t\treturn indexes;\n\t\t}\n\t\tif (compareResult === END) {\n\t\t\toffset = endOffset;\n\t\t\tposition = \"end\";\n\t\t\tlen = end.length;\n\t\t}\n\t\tif (compareResult === START) {\n\t\t\toffset = startOffset;\n\t\t\tposition = \"start\";\n\t\t\tlen = start.length;\n\t\t}\n\t\tif (position === \"start\" && fullText[offset + start.length] === \"=\") {\n\t\t\tindexes.push({\n\t\t\t\toffset: startOffset,\n\t\t\t\tposition: \"start\",\n\t\t\t\tlength: start.length,\n\t\t\t\tchangedelimiter: true\n\t\t\t});\n\t\t\tvar nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n\t\t\tvar _endOffset = fullText.indexOf(end, nextEqual + 1);\n\n\t\t\tindexes.push({\n\t\t\t\toffset: _endOffset,\n\t\t\t\tposition: \"end\",\n\t\t\t\tlength: end.length,\n\t\t\t\tchangedelimiter: true\n\t\t\t});\n\t\t\tvar insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n\n\t\t\tvar _splitDelimiters = splitDelimiters(insideTag);\n\n\t\t\tvar _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n\n\t\t\tstart = _splitDelimiters2[0];\n\t\t\tend = _splitDelimiters2[1];\n\n\t\t\toffset = _endOffset;\n\t\t\tcontinue;\n\t\t}\n\t\tindexes.push({ offset: offset, position: position, length: len });\n\t}\n}\n\nfunction Reader(innerContentParts) {\n\tvar _this = this;\n\n\tthis.innerContentParts = innerContentParts;\n\tthis.full = \"\";\n\tthis.parseDelimiters = function (delimiters) {\n\t\t_this.full = _this.innerContentParts.map(function (p) {\n\t\t\treturn p.value;\n\t\t}).join(\"\");\n\t\tvar delimiterMatches = getAllIndexes(_this.full, delimiters);\n\n\t\tvar offset = 0;\n\t\tvar ranges = _this.innerContentParts.map(function (part) {\n\t\t\toffset += part.value.length;\n\t\t\treturn { offset: offset - part.value.length, lIndex: part.lIndex };\n\t\t});\n\n\t\tvar errors = getDelimiterErrors(delimiterMatches, _this.full, ranges);\n\t\tvar cutNext = 0;\n\t\tvar delimiterIndex = 0;\n\n\t\t_this.parsed = ranges.map(function (p, i) {\n\t\t\tvar offset = p.offset;\n\n\t\t\tvar range = [offset, offset + this.innerContentParts[i].value.length];\n\t\t\tvar partContent = this.innerContentParts[i].value;\n\t\t\tvar delimitersInOffset = [];\n\t\t\twhile (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {\n\t\t\t\tdelimitersInOffset.push(delimiterMatches[delimiterIndex]);\n\t\t\t\tdelimiterIndex++;\n\t\t\t}\n\t\t\tvar parts = [];\n\t\t\tvar cursor = 0;\n\t\t\tif (cutNext > 0) {\n\t\t\t\tcursor = cutNext;\n\t\t\t\tcutNext = 0;\n\t\t\t}\n\t\t\tvar insideDelimiterChange = void 0;\n\t\t\tdelimitersInOffset.forEach(function (delimiterInOffset) {\n\t\t\t\tvar value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n\t\t\t\tif (value.length > 0) {\n\t\t\t\t\tif (insideDelimiterChange) {\n\t\t\t\t\t\tif (delimiterInOffset.changedelimiter) {\n\t\t\t\t\t\t\tcursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n\t\t\t\t\t\t\tinsideDelimiterChange = delimiterInOffset.position === \"start\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push({ type: \"content\", value: value, offset: cursor + offset });\n\t\t\t\t\tcursor += value.length;\n\t\t\t\t}\n\t\t\t\tvar delimiterPart = {\n\t\t\t\t\ttype: \"delimiter\",\n\t\t\t\t\tposition: delimiterInOffset.position,\n\t\t\t\t\toffset: cursor + offset\n\t\t\t\t};\n\t\t\t\tif (delimiterInOffset.error) {\n\t\t\t\t\tdelimiterPart.error = delimiterInOffset.error;\n\t\t\t\t}\n\t\t\t\tif (delimiterInOffset.changedelimiter) {\n\t\t\t\t\tinsideDelimiterChange = delimiterInOffset.position === \"start\";\n\t\t\t\t\tcursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tparts.push(delimiterPart);\n\t\t\t\tcursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n\t\t\t});\n\t\t\tcutNext = cursor - partContent.length;\n\t\t\tvar value = partContent.substr(cursor);\n\t\t\tif (value.length > 0) {\n\t\t\t\tparts.push({ type: \"content\", value: value, offset: offset });\n\t\t\t}\n\t\t\treturn parts;\n\t\t}, _this);\n\t\t_this.errors = errors;\n\t};\n}\n\nfunction getContentParts(xmlparsed) {\n\tvar inTextTag = false;\n\tvar innerContentParts = [];\n\txmlparsed.forEach(function (part) {\n\t\tinTextTag = updateInTextTag(part, inTextTag);\n\t\tif (inTextTag && part.type === \"content\") {\n\t\t\tinnerContentParts.push(part);\n\t\t}\n\t});\n\treturn innerContentParts;\n}\n\nmodule.exports = {\n\tparse: function parse(xmlparsed, delimiters) {\n\t\tvar inTextTag = false;\n\t\tvar reader = new Reader(getContentParts(xmlparsed));\n\t\treader.parseDelimiters(delimiters);\n\n\t\tvar lexed = [];\n\t\tvar index = 0;\n\t\txmlparsed.forEach(function (part) {\n\t\t\tinTextTag = updateInTextTag(part, inTextTag);\n\t\t\tif (part.type === \"content\") {\n\t\t\t\tpart.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n\t\t\t}\n\t\t\tif (inTextTag && part.type === \"content\") {\n\t\t\t\tArray.prototype.push.apply(lexed, reader.parsed[index].map(function (p) {\n\t\t\t\t\tif (p.type === \"content\") {\n\t\t\t\t\t\tp.position = \"insidetag\";\n\t\t\t\t\t}\n\t\t\t\t\treturn p;\n\t\t\t\t}));\n\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tlexed.push(part);\n\t\t\t}\n\t\t});\n\t\tlexed = lexed.map(function (p, i) {\n\t\t\tp.lIndex = i;\n\t\t\treturn p;\n\t\t});\n\t\treturn { errors: reader.errors, lexed: lexed };\n\t},\n\txmlparse: function xmlparse(content, xmltags) {\n\t\tvar matches = tagMatcher(content, xmltags.text, xmltags.other);\n\t\tvar cursor = 0;\n\t\tvar parsed = matches.reduce(function (parsed, match) {\n\t\t\tvar value = content.substr(cursor, match.offset - cursor);\n\t\t\tif (value.length > 0) {\n\t\t\t\tparsed.push({ type: \"content\", value: value });\n\t\t\t}\n\t\t\tcursor = match.offset + match.value.length;\n\t\t\tdelete match.offset;\n\t\t\tif (match.value.length > 0) {\n\t\t\t\tparsed.push(match);\n\t\t\t}\n\t\t\treturn parsed;\n\t\t}, []);\n\t\tvar value = content.substr(cursor);\n\t\tif (value.length > 0) {\n\t\t\tparsed.push({ type: \"content\", value: value });\n\t\t}\n\t\treturn parsed;\n\t}\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/lexer.js?");

/***/ }),

/***/ "./es6/mergesort.js":
/*!**************************!*\
  !*** ./es6/mergesort.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction getMinFromArrays(arrays, state) {\n\tvar minIndex = -1;\n\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\tif (state[i] >= arrays[i].length) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n\t\t\tminIndex = i;\n\t\t}\n\t}\n\tif (minIndex === -1) {\n\t\tthrow new Error(\"minIndex negative\");\n\t}\n\treturn minIndex;\n}\n\nmodule.exports = function (arrays) {\n\tvar totalLength = arrays.reduce(function (sum, array) {\n\t\treturn sum + array.length;\n\t}, 0);\n\tarrays = arrays.filter(function (array) {\n\t\treturn array.length > 0;\n\t});\n\n\tvar resultArray = new Array(totalLength);\n\n\tvar state = arrays.map(function () {\n\t\treturn 0;\n\t});\n\n\tvar i = 0;\n\n\twhile (i <= totalLength - 1) {\n\t\tvar arrayIndex = getMinFromArrays(arrays, state);\n\t\tresultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n\t\tstate[arrayIndex]++;\n\t\ti++;\n\t}\n\n\treturn resultArray;\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/mergesort.js?");

/***/ }),

/***/ "./es6/module-wrapper.js":
/*!*******************************!*\
  !*** ./es6/module-wrapper.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction emptyFun() {}\nfunction identity(i) {\n\treturn i;\n}\nmodule.exports = function (module) {\n\tvar defaults = {\n\t\tset: emptyFun,\n\t\tparse: emptyFun,\n\t\trender: emptyFun,\n\t\tgetTraits: emptyFun,\n\t\tnullGetter: emptyFun,\n\t\toptionsTransformer: identity,\n\t\tpostrender: identity,\n\t\terrorsTransformer: identity,\n\t\tgetRenderedMap: identity,\n\t\tpostparse: identity,\n\t\ton: emptyFun,\n\t\tresolve: emptyFun\n\t};\n\tif (Object.keys(defaults).every(function (key) {\n\t\treturn !module[key];\n\t})) {\n\t\tthrow new Error(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n\t}\n\tObject.keys(defaults).forEach(function (key) {\n\t\tmodule[key] = module[key] || defaults[key];\n\t});\n\treturn module;\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/module-wrapper.js?");

/***/ }),

/***/ "./es6/modules/expand-pair-trait.js":
/*!******************************************!*\
  !*** ./es6/modules/expand-pair-trait.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar traitName = \"expandPair\";\nvar mergeSort = __webpack_require__(/*! ../mergesort */ \"./es6/mergesort.js\");\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    getLeft = _require.getLeft,\n    getRight = _require.getRight;\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar _require2 = __webpack_require__(/*! ../traits */ \"./es6/traits.js\"),\n    getExpandToDefault = _require2.getExpandToDefault;\n\nvar _require3 = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    getUnmatchedLoopException = _require3.getUnmatchedLoopException,\n    getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\n    throwLocationInvalid = _require3.throwLocationInvalid;\n\nfunction getOpenCountChange(part) {\n\tswitch (part.location) {\n\t\tcase \"start\":\n\t\t\treturn 1;\n\t\tcase \"end\":\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tthrowLocationInvalid(part);\n\t}\n}\n\nfunction getPairs(traits) {\n\tvar errors = [];\n\tvar pairs = [];\n\tif (traits.length === 0) {\n\t\treturn { pairs: pairs, errors: errors };\n\t}\n\tvar countOpen = 1;\n\n\tvar _traits = _slicedToArray(traits, 1),\n\t    firstTrait = _traits[0];\n\n\tif (firstTrait.part.location === \"start\") {\n\t\tfor (var i = 1; i < traits.length; i++) {\n\t\t\tvar currentTrait = traits[i];\n\t\t\tcountOpen += getOpenCountChange(currentTrait.part);\n\t\t\tif (countOpen === 0) {\n\t\t\t\tvar _outer = getPairs(traits.slice(i + 1));\n\t\t\t\tif (currentTrait.part.value !== firstTrait.part.value && currentTrait.part.value !== \"\") {\n\t\t\t\t\terrors.push(getClosingTagNotMatchOpeningTag({\n\t\t\t\t\t\ttags: [firstTrait.part, currentTrait.part]\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\tpairs = [[firstTrait, currentTrait]];\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tpairs: pairs.concat(_outer.pairs),\n\t\t\t\t\terrors: errors.concat(_outer.errors)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\tvar part = firstTrait.part;\n\n\terrors.push(getUnmatchedLoopException({ part: part, location: part.location }));\n\tvar outer = getPairs(traits.slice(1));\n\treturn { pairs: outer.pairs, errors: errors.concat(outer.errors) };\n}\n\nvar expandPairTrait = {\n\tname: \"ExpandPairTrait\",\n\toptionsTransformer: function optionsTransformer(options, docxtemplater) {\n\t\tthis.expandTags = docxtemplater.fileTypeConfig.expandTags.concat(docxtemplater.options.paragraphLoop ? docxtemplater.fileTypeConfig.onParagraphLoop : []);\n\t\treturn options;\n\t},\n\tpostparse: function postparse(postparsed, _ref) {\n\t\tvar _this = this;\n\n\t\tvar getTraits = _ref.getTraits,\n\t\t    postparse = _ref.postparse;\n\n\t\tvar traits = getTraits(traitName, postparsed);\n\t\ttraits = traits.map(function (trait) {\n\t\t\treturn trait || [];\n\t\t});\n\t\ttraits = mergeSort(traits);\n\n\t\tvar _getPairs = getPairs(traits),\n\t\t    pairs = _getPairs.pairs,\n\t\t    errors = _getPairs.errors;\n\n\t\tvar expandedPairs = pairs.map(function (pair) {\n\t\t\tvar expandTo = pair[0].part.expandTo;\n\n\t\t\tif (expandTo === \"auto\") {\n\t\t\t\tvar result = getExpandToDefault(postparsed, pair, _this.expandTags);\n\t\t\t\tif (result.error) {\n\t\t\t\t\terrors.push(result.error);\n\t\t\t\t}\n\t\t\t\texpandTo = result.value;\n\t\t\t}\n\t\t\tif (!expandTo) {\n\t\t\t\treturn [pair[0].offset, pair[1].offset];\n\t\t\t}\n\t\t\tvar left = getLeft(postparsed, expandTo, pair[0].offset);\n\t\t\tvar right = getRight(postparsed, expandTo, pair[1].offset);\n\t\t\treturn [left, right];\n\t\t});\n\n\t\tvar currentPairIndex = 0;\n\t\tvar innerParts = void 0;\n\t\tvar newParsed = postparsed.reduce(function (newParsed, part, i) {\n\t\t\tvar inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i;\n\t\t\tvar pair = pairs[currentPairIndex];\n\t\t\tvar expandedPair = expandedPairs[currentPairIndex];\n\t\t\tif (!inPair) {\n\t\t\t\tnewParsed.push(part);\n\t\t\t\treturn newParsed;\n\t\t\t}\n\t\t\tif (expandedPair[0] === i) {\n\t\t\t\tinnerParts = [];\n\t\t\t}\n\t\t\tif (pair[0].offset !== i && pair[1].offset !== i) {\n\t\t\t\tinnerParts.push(part);\n\t\t\t}\n\t\t\tif (expandedPair[1] === i) {\n\t\t\t\tvar basePart = postparsed[pair[0].offset];\n\t\t\t\tbasePart.subparsed = postparse(innerParts, { basePart: basePart });\n\t\t\t\tdelete basePart.location;\n\t\t\t\tdelete basePart.expandTo;\n\t\t\t\tnewParsed.push(basePart);\n\t\t\t\tcurrentPairIndex++;\n\t\t\t}\n\t\t\treturn newParsed;\n\t\t}, []);\n\t\treturn { postparsed: newParsed, errors: errors };\n\t}\n};\n\nmodule.exports = function () {\n\treturn wrapper(expandPairTrait);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/expand-pair-trait.js?");

/***/ }),

/***/ "./es6/modules/loop.js":
/*!*****************************!*\
  !*** ./es6/modules/loop.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    mergeObjects = _require.mergeObjects,\n    chunkBy = _require.chunkBy,\n    last = _require.last,\n    isParagraphStart = _require.isParagraphStart,\n    isParagraphEnd = _require.isParagraphEnd,\n    isContent = _require.isContent;\n\nvar dashInnerRegex = /^-([^\\s]+)\\s(.+)$/;\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar moduleName = \"loop\";\n\nfunction hasContent(parts) {\n\treturn parts.some(function (part) {\n\t\treturn isContent(part);\n\t});\n}\n\nfunction isEnclosedByParagraphs(parsed) {\n\tif (parsed.length === 0) {\n\t\treturn false;\n\t}\n\treturn isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\n\nfunction getOffset(chunk) {\n\treturn hasContent(chunk) ? 0 : chunk.length;\n}\n\nvar loopModule = {\n\tname: \"LoopModule\",\n\tprefix: {\n\t\tstart: \"#\",\n\t\tend: \"/\",\n\t\tdash: \"-\",\n\t\tinverted: \"^\"\n\t},\n\tparse: function parse(placeHolderContent) {\n\t\tvar module = moduleName;\n\t\tvar type = \"placeholder\";\n\t\tvar _prefix = this.prefix,\n\t\t    start = _prefix.start,\n\t\t    inverted = _prefix.inverted,\n\t\t    dash = _prefix.dash,\n\t\t    end = _prefix.end;\n\n\t\tif (placeHolderContent[0] === start) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: placeHolderContent.substr(1),\n\t\t\t\texpandTo: \"auto\",\n\t\t\t\tmodule: module,\n\t\t\t\tlocation: \"start\",\n\t\t\t\tinverted: false\n\t\t\t};\n\t\t}\n\t\tif (placeHolderContent[0] === inverted) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: placeHolderContent.substr(1),\n\t\t\t\texpandTo: \"auto\",\n\t\t\t\tmodule: module,\n\t\t\t\tlocation: \"start\",\n\t\t\t\tinverted: true\n\t\t\t};\n\t\t}\n\t\tif (placeHolderContent[0] === end) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: placeHolderContent.substr(1),\n\t\t\t\tmodule: module,\n\t\t\t\tlocation: \"end\"\n\t\t\t};\n\t\t}\n\t\tif (placeHolderContent[0] === dash) {\n\t\t\tvar value = placeHolderContent.replace(dashInnerRegex, \"$2\");\n\t\t\tvar expandTo = placeHolderContent.replace(dashInnerRegex, \"$1\");\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: value,\n\t\t\t\texpandTo: expandTo,\n\t\t\t\tmodule: module,\n\t\t\t\tlocation: \"start\",\n\t\t\t\tinverted: false\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t},\n\tgetTraits: function getTraits(traitName, parsed) {\n\t\tif (traitName !== \"expandPair\") {\n\t\t\treturn;\n\t\t}\n\n\t\treturn parsed.reduce(function (tags, part, offset) {\n\t\t\tif (part.type === \"placeholder\" && part.module === moduleName) {\n\t\t\t\ttags.push({ part: part, offset: offset });\n\t\t\t}\n\t\t\treturn tags;\n\t\t}, []);\n\t},\n\tpostparse: function postparse(parsed, _ref) {\n\t\tvar basePart = _ref.basePart;\n\n\t\tif (!isEnclosedByParagraphs(parsed)) {\n\t\t\treturn parsed;\n\t\t}\n\t\tif (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName) {\n\t\t\treturn parsed;\n\t\t}\n\t\tvar chunks = chunkBy(parsed, function (p) {\n\t\t\tif (isParagraphStart(p)) {\n\t\t\t\treturn \"start\";\n\t\t\t}\n\t\t\tif (isParagraphEnd(p)) {\n\t\t\t\treturn \"end\";\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t\tif (chunks.length <= 2) {\n\t\t\treturn parsed;\n\t\t}\n\t\tvar firstChunk = chunks[0];\n\t\tvar lastChunk = last(chunks);\n\t\tvar firstOffset = getOffset(firstChunk);\n\t\tvar lastOffset = getOffset(lastChunk);\n\t\tif (firstOffset === 0 || lastOffset === 0) {\n\t\t\treturn parsed;\n\t\t}\n\t\treturn parsed.slice(firstOffset, parsed.length - lastOffset);\n\t},\n\trender: function render(part, options) {\n\t\tif (!part.type === \"placeholder\" || part.module !== moduleName) {\n\t\t\treturn null;\n\t\t}\n\t\tvar totalValue = [];\n\t\tvar errors = [];\n\t\tfunction loopOver(scope, i) {\n\t\t\tvar scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i);\n\t\t\tvar subRendered = options.render(mergeObjects({}, options, {\n\t\t\t\tcompiled: part.subparsed,\n\t\t\t\ttags: {},\n\t\t\t\tscopeManager: scopeManager\n\t\t\t}));\n\t\t\ttotalValue = totalValue.concat(subRendered.parts);\n\t\t\terrors = errors.concat(subRendered.errors || []);\n\t\t}\n\t\toptions.scopeManager.loopOver(part.value, loopOver, part.inverted, {\n\t\t\tpart: part\n\t\t});\n\t\treturn { value: totalValue.join(\"\"), errors: errors };\n\t},\n\tresolve: function resolve(part, options) {\n\t\tif (!part.type === \"placeholder\" || part.module !== moduleName) {\n\t\t\treturn null;\n\t\t}\n\t\tvar value = options.scopeManager.getValue(part.value, { part: part });\n\t\tvar promises = [];\n\t\tfunction loopOver(scope, i) {\n\t\t\tvar scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i);\n\t\t\tpromises.push(options.resolve(mergeObjects(options, {\n\t\t\t\tcompiled: part.subparsed,\n\t\t\t\ttags: {},\n\t\t\t\tscopeManager: scopeManager\n\t\t\t})));\n\t\t}\n\t\treturn Promise.resolve(value).then(function (value) {\n\t\t\toptions.scopeManager.loopOverValue(value, loopOver, part.inverted);\n\t\t\treturn Promise.all(promises).then(function (r) {\n\t\t\t\treturn r.map(function (_ref2) {\n\t\t\t\t\tvar resolved = _ref2.resolved;\n\n\t\t\t\t\treturn resolved;\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n};\n\nmodule.exports = function () {\n\treturn wrapper(loopModule);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/loop.js?");

/***/ }),

/***/ "./es6/modules/rawxml.js":
/*!*******************************!*\
  !*** ./es6/modules/rawxml.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar traits = __webpack_require__(/*! ../traits */ \"./es6/traits.js\");\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    isContent = _require.isContent;\n\nvar _require2 = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph;\n\nvar moduleName = \"rawxml\";\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nfunction getNearestLeft(parsed, elements, index) {\n\tfor (var i = index; i >= 0; i--) {\n\t\tvar part = parsed[i];\n\t\tfor (var j = 0, len = elements.length; j < len; j++) {\n\t\t\tvar element = elements[j];\n\t\t\tif (part.value.indexOf(\"<\" + element) === 0 && [\">\", \" \"].indexOf(part.value[element.length + 1]) !== -1) {\n\t\t\t\treturn elements[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction getNearestRight(parsed, elements, index) {\n\tfor (var i = index, l = parsed.length; i < l; i++) {\n\t\tvar part = parsed[i];\n\t\tfor (var j = 0, len = elements.length; j < len; j++) {\n\t\t\tvar element = elements[j];\n\t\t\tif (part.value === \"</\" + element + \">\") {\n\t\t\t\treturn elements[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction getInner(_ref) {\n\tvar part = _ref.part,\n\t    left = _ref.left,\n\t    right = _ref.right,\n\t    postparsed = _ref.postparsed,\n\t    index = _ref.index;\n\n\tvar before = getNearestLeft(postparsed, [\"w:p\", \"w:tc\"], left - 1);\n\tvar after = getNearestRight(postparsed, [\"w:p\", \"w:tc\"], right + 1);\n\tif (after === \"w:tc\" && before === \"w:tc\") {\n\t\tpart.emptyValue = \"<w:p></w:p>\";\n\t}\n\tvar paragraphParts = postparsed.slice(left + 1, right);\n\tparagraphParts.forEach(function (p, i) {\n\t\tif (i === index - left - 1) {\n\t\t\treturn;\n\t\t}\n\t\tif (isContent(p)) {\n\t\t\tthrowRawTagShouldBeOnlyTextInParagraph({ paragraphParts: paragraphParts, part: part });\n\t\t}\n\t});\n\treturn part;\n}\n\nvar rawXmlModule = {\n\tname: \"RawXmlModule\",\n\tprefix: \"@\",\n\toptionsTransformer: function optionsTransformer(options, docxtemplater) {\n\t\tthis.fileTypeConfig = docxtemplater.fileTypeConfig;\n\t\treturn options;\n\t},\n\tparse: function parse(placeHolderContent) {\n\t\tvar type = \"placeholder\";\n\t\tif (placeHolderContent[0] !== this.prefix) {\n\t\t\treturn null;\n\t\t}\n\t\treturn { type: type, value: placeHolderContent.substr(1), module: moduleName };\n\t},\n\tpostparse: function postparse(postparsed) {\n\t\treturn traits.expandToOne(postparsed, {\n\t\t\tmoduleName: moduleName,\n\t\t\tgetInner: getInner,\n\t\t\texpandTo: this.fileTypeConfig.tagRawXml\n\t\t});\n\t},\n\trender: function render(part, options) {\n\t\tif (part.module !== moduleName) {\n\t\t\treturn null;\n\t\t}\n\t\tvar value = options.scopeManager.getValue(part.value, { part: part });\n\t\tif (value == null) {\n\t\t\tvalue = options.nullGetter(part);\n\t\t}\n\t\tif (!value) {\n\t\t\treturn { value: part.emptyValue || \"\" };\n\t\t}\n\t\treturn { value: value };\n\t},\n\tresolve: function resolve(part, options) {\n\t\tif (!part.type === \"placeholder\" || part.module !== moduleName) {\n\t\t\treturn null;\n\t\t}\n\t\treturn options.scopeManager.getValueAsync(part.value, { part: part }).then(function (value) {\n\t\t\tif (value == null) {\n\t\t\t\treturn options.nullGetter(part);\n\t\t\t}\n\t\t\treturn value;\n\t\t});\n\t}\n};\n\nmodule.exports = function () {\n\treturn wrapper(rawXmlModule);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/rawxml.js?");

/***/ }),

/***/ "./es6/modules/render.js":
/*!*******************************!*\
  !*** ./es6/modules/render.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar _require = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    getScopeCompilationError = _require.getScopeCompilationError;\n\nvar _require2 = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    utf8ToWord = _require2.utf8ToWord,\n    hasCorruptCharacters = _require2.hasCorruptCharacters;\n\nvar _require3 = __webpack_require__(/*! ../errors */ \"./es6/errors.js\"),\n    throwCorruptCharacters = _require3.throwCorruptCharacters;\n\nvar ftprefix = {\n\tdocx: \"w\",\n\tpptx: \"a\"\n};\n\nvar Render = function () {\n\tfunction Render() {\n\t\t_classCallCheck(this, Render);\n\n\t\tthis.name = \"Render\";\n\t\tthis.recordRun = false;\n\t\tthis.recordedRun = [];\n\t}\n\n\t_createClass(Render, [{\n\t\tkey: \"set\",\n\t\tvalue: function set(obj) {\n\t\t\tif (obj.compiled) {\n\t\t\t\tthis.compiled = obj.compiled;\n\t\t\t}\n\t\t\tif (obj.data != null) {\n\t\t\t\tthis.data = obj.data;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"getRenderedMap\",\n\t\tvalue: function getRenderedMap(mapper) {\n\t\t\tvar _this = this;\n\n\t\t\treturn Object.keys(this.compiled).reduce(function (mapper, from) {\n\t\t\t\tmapper[from] = { from: from, data: _this.data };\n\t\t\t\treturn mapper;\n\t\t\t}, mapper);\n\t\t}\n\t}, {\n\t\tkey: \"optionsTransformer\",\n\t\tvalue: function optionsTransformer(options, docxtemplater) {\n\t\t\tthis.parser = docxtemplater.parser;\n\t\t\tthis.fileType = docxtemplater.fileType;\n\t\t\treturn options;\n\t\t}\n\t}, {\n\t\tkey: \"postparse\",\n\t\tvalue: function postparse(postparsed) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar errors = [];\n\t\t\tpostparsed.forEach(function (p) {\n\t\t\t\tif (p.type === \"placeholder\") {\n\t\t\t\t\tvar tag = p.value;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_this2.parser(tag, { tag: p });\n\t\t\t\t\t} catch (rootError) {\n\t\t\t\t\t\terrors.push(getScopeCompilationError({ tag: tag, rootError: rootError }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn { postparsed: postparsed, errors: errors };\n\t\t}\n\t}, {\n\t\tkey: \"recordRuns\",\n\t\tvalue: function recordRuns(part) {\n\t\t\tif (part.tag === ftprefix[this.fileType] + \":r\") {\n\t\t\t\tthis.recordRun = false;\n\t\t\t\tthis.recordedRun = [];\n\t\t\t} else if (part.tag === ftprefix[this.fileType] + \":rPr\") {\n\t\t\t\tif (part.position === \"start\") {\n\t\t\t\t\tthis.recordRun = true;\n\t\t\t\t\tthis.recordedRun = [part.value];\n\t\t\t\t}\n\t\t\t\tif (part.position === \"end\") {\n\t\t\t\t\tthis.recordedRun.push(part.value);\n\t\t\t\t\tthis.recordRun = false;\n\t\t\t\t}\n\t\t\t} else if (this.recordRun) {\n\t\t\t\tthis.recordedRun.push(part.value);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render(part, options) {\n\t\t\tvar scopeManager = options.scopeManager;\n\n\t\t\tif (options.linebreaks) {\n\t\t\t\tthis.recordRuns(part);\n\t\t\t}\n\t\t\tif (part.type === \"placeholder\" && !part.module) {\n\t\t\t\tvar value = scopeManager.getValue(part.value, { part: part });\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = options.nullGetter(part);\n\t\t\t\t}\n\t\t\t\tif (hasCorruptCharacters(value)) {\n\t\t\t\t\tthrowCorruptCharacters({ tag: part.value, value: value });\n\t\t\t\t}\n\t\t\t\tif (options.linebreaks) {\n\t\t\t\t\tvar p = ftprefix[this.fileType];\n\t\t\t\t\tvar br = this.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n\t\t\t\t\tvar lines = value.split(\"\\n\");\n\t\t\t\t\tvar runprops = this.recordedRun.join(\"\");\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: lines.map(function (line) {\n\t\t\t\t\t\t\treturn utf8ToWord(line);\n\t\t\t\t\t\t}).join(\"</\" + p + \":t></\" + p + \":r>\" + br + \"<\" + p + \":r>\" + runprops + \"<\" + p + \":t>\")\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn { value: utf8ToWord(value) };\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Render;\n}();\n\nmodule.exports = function () {\n\treturn wrapper(new Render());\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/render.js?");

/***/ }),

/***/ "./es6/modules/space-preserve.js":
/*!***************************************!*\
  !*** ./es6/modules/space-preserve.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar wrapper = __webpack_require__(/*! ../module-wrapper */ \"./es6/module-wrapper.js\");\n\nvar _require = __webpack_require__(/*! ../doc-utils */ \"./es6/doc-utils.js\"),\n    isTextStart = _require.isTextStart,\n    isTextEnd = _require.isTextEnd,\n    endsWith = _require.endsWith,\n    startsWith = _require.startsWith;\n\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\n\nfunction isWtStart(part) {\n\treturn isTextStart(part) && part.tag === \"w:t\";\n}\n\nfunction addXMLPreserve(chunk, index) {\n\tvar tag = chunk[index].value;\n\tif (chunk[index + 1].value === \"</w:t>\") {\n\t\treturn tag;\n\t}\n\tif (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n\t\treturn tag;\n\t}\n\treturn tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\n\nfunction isInsideLoop(meta, chunk) {\n\treturn meta && meta.basePart && chunk.length > 1;\n}\n\nvar spacePreserve = {\n\tname: \"SpacePreserveModule\",\n\tpostparse: function postparse(postparsed, meta) {\n\t\tvar chunk = [],\n\t\t    inTextTag = false,\n\t\t    endLindex = 0,\n\t\t    lastTextTag = 0;\n\t\tfunction isStartingPlaceHolder(part, chunk) {\n\t\t\treturn !endLindex && part.type === \"placeholder\" && (!part.module || part.module === \"loop\") && chunk.length > 1;\n\t\t}\n\t\tvar result = postparsed.reduce(function (postparsed, part) {\n\t\t\tif (isWtStart(part)) {\n\t\t\t\tinTextTag = true;\n\t\t\t\tlastTextTag = chunk.length;\n\t\t\t}\n\t\t\tif (!inTextTag) {\n\t\t\t\tpostparsed.push(part);\n\t\t\t\treturn postparsed;\n\t\t\t}\n\t\t\tchunk.push(part);\n\t\t\tif (isInsideLoop(meta, chunk)) {\n\t\t\t\tendLindex = meta.basePart.endLindex;\n\t\t\t\tchunk[0].value = addXMLPreserve(chunk, 0);\n\t\t\t}\n\t\t\tif (isStartingPlaceHolder(part, chunk)) {\n\t\t\t\tendLindex = part.endLindex;\n\t\t\t\tchunk[0].value = addXMLPreserve(chunk, 0);\n\t\t\t}\n\t\t\tif (isTextEnd(part) && part.lIndex > endLindex) {\n\t\t\t\tif (endLindex !== 0) {\n\t\t\t\t\tchunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n\t\t\t\t}\n\t\t\t\tArray.prototype.push.apply(postparsed, chunk);\n\t\t\t\tchunk = [];\n\t\t\t\tinTextTag = false;\n\t\t\t\tendLindex = 0;\n\t\t\t\tlastTextTag = 0;\n\t\t\t}\n\t\t\treturn postparsed;\n\t\t}, []);\n\t\tArray.prototype.push.apply(result, chunk);\n\t\treturn result;\n\t},\n\tpostrender: function postrender(parts) {\n\t\treturn parts.filter(function (p) {\n\t\t\treturn p.length !== 0;\n\t\t}).reduce(function (newParts, p, index, parts) {\n\t\t\tif (p.indexOf('<w:t xml:space=\"preserve\"></w:t>') !== -1) {\n\t\t\t\tp = p.replace(/<w:t xml:space=\"preserve\"><\\/w:t>/g, \"<w:t/>\");\n\t\t\t}\n\t\t\tif (endsWith(p, wTpreserve) && startsWith(parts[index + 1], wtEnd)) {\n\t\t\t\tp = p.substr(0, p.length - wTpreservelen) + \"<w:t/>\";\n\t\t\t\tparts[index + 1] = parts[index + 1].substr(wtEndlen);\n\t\t\t}\n\t\t\tnewParts.push(p);\n\t\t\treturn newParts;\n\t\t}, []);\n\t}\n};\nmodule.exports = function () {\n\treturn wrapper(spacePreserve);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/modules/space-preserve.js?");

/***/ }),

/***/ "./es6/parser.js":
/*!***********************!*\
  !*** ./es6/parser.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    wordToUtf8 = _require.wordToUtf8,\n    concatArrays = _require.concatArrays;\n\nfunction moduleParse(modules, placeHolderContent, parsed, startOffset, endLindex) {\n\tvar moduleParsed = void 0;\n\tfor (var i = 0, l = modules.length; i < l; i++) {\n\t\tvar _module = modules[i];\n\t\tmoduleParsed = _module.parse(placeHolderContent);\n\t\tif (moduleParsed) {\n\t\t\tmoduleParsed.offset = startOffset;\n\t\t\tmoduleParsed.endLindex = endLindex;\n\t\t\tmoduleParsed.lIndex = endLindex;\n\t\t\tparsed.push(moduleParsed);\n\t\t\treturn parsed;\n\t\t}\n\t}\n\tparsed.push({\n\t\ttype: \"placeholder\",\n\t\tvalue: placeHolderContent,\n\t\toffset: startOffset,\n\t\tendLindex: endLindex,\n\t\tlIndex: endLindex\n\t});\n\treturn parsed;\n}\n\nvar parser = {\n\tpostparse: function postparse(postparsed, modules) {\n\t\tfunction getTraits(traitName, postparsed) {\n\t\t\treturn modules.map(function (module) {\n\t\t\t\treturn module.getTraits(traitName, postparsed);\n\t\t\t});\n\t\t}\n\t\tvar errors = [];\n\t\tfunction postparse(postparsed, options) {\n\t\t\treturn modules.reduce(function (postparsed, module) {\n\t\t\t\tvar r = module.postparse(postparsed, _extends({}, options, {\n\t\t\t\t\tpostparse: postparse,\n\t\t\t\t\tgetTraits: getTraits\n\t\t\t\t}));\n\t\t\t\tif (r.errors) {\n\t\t\t\t\terrors = concatArrays([errors, r.errors]);\n\t\t\t\t\treturn r.postparsed;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}, postparsed);\n\t\t}\n\t\treturn { postparsed: postparse(postparsed), errors: errors };\n\t},\n\tparse: function parse(lexed, modules) {\n\t\tvar inPlaceHolder = false;\n\t\tvar placeHolderContent = \"\";\n\t\tvar startOffset = void 0;\n\t\tvar tailParts = [];\n\t\treturn lexed.reduce(function lexedToParsed(parsed, token) {\n\t\t\tif (token.type === \"delimiter\") {\n\t\t\t\tinPlaceHolder = token.position === \"start\";\n\t\t\t\tif (token.position === \"end\") {\n\t\t\t\t\tvar endLindex = token.lIndex;\n\t\t\t\t\tplaceHolderContent = wordToUtf8(placeHolderContent);\n\t\t\t\t\tparsed = moduleParse(modules, placeHolderContent, parsed, startOffset, endLindex);\n\t\t\t\t\tstartOffset = null;\n\t\t\t\t\tArray.prototype.push.apply(parsed, tailParts);\n\t\t\t\t\ttailParts = [];\n\t\t\t\t}\n\t\t\t\tif (token.position === \"start\") {\n\t\t\t\t\ttailParts = [];\n\t\t\t\t\tstartOffset = token.offset;\n\t\t\t\t}\n\t\t\t\tplaceHolderContent = \"\";\n\t\t\t\treturn parsed;\n\t\t\t}\n\t\t\tif (!inPlaceHolder) {\n\t\t\t\tparsed.push(token);\n\t\t\t\treturn parsed;\n\t\t\t}\n\t\t\tif (token.type !== \"content\" || token.position !== \"insidetag\") {\n\t\t\t\ttailParts.push(token);\n\t\t\t\treturn parsed;\n\t\t\t}\n\t\t\tplaceHolderContent += token.value;\n\t\t\treturn parsed;\n\t\t}, []);\n\t}\n};\n\nmodule.exports = parser;\n\n//# sourceURL=webpack://docxtemplater/./es6/parser.js?");

/***/ }),

/***/ "./es6/postrender.js":
/*!***************************!*\
  !*** ./es6/postrender.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction postrender(parts, options) {\n\tfor (var i = 0, l = options.modules.length; i < l; i++) {\n\t\tvar _module = options.modules[i];\n\t\tparts = _module.postrender(parts, options);\n\t}\n\treturn parts.join(\"\");\n}\n\nmodule.exports = postrender;\n\n//# sourceURL=webpack://docxtemplater/./es6/postrender.js?");

/***/ }),

/***/ "./es6/render.js":
/*!***********************!*\
  !*** ./es6/render.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    concatArrays = _require.concatArrays;\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    throwUnimplementedTagType = _require2.throwUnimplementedTagType;\n\nfunction moduleRender(part, options) {\n\tvar moduleRendered = void 0;\n\tfor (var i = 0, l = options.modules.length; i < l; i++) {\n\t\tvar _module = options.modules[i];\n\t\tmoduleRendered = _module.render(part, options);\n\t\tif (moduleRendered) {\n\t\t\treturn moduleRendered;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction render(options) {\n\tvar baseNullGetter = options.baseNullGetter;\n\tvar compiled = options.compiled,\n\t    scopeManager = options.scopeManager;\n\n\toptions.nullGetter = function (part, sm) {\n\t\treturn baseNullGetter(part, sm || scopeManager);\n\t};\n\tvar errors = [];\n\tvar parts = compiled.map(function (part) {\n\t\tvar moduleRendered = moduleRender(part, options);\n\t\tif (moduleRendered) {\n\t\t\tif (moduleRendered.errors) {\n\t\t\t\terrors = concatArrays([errors, moduleRendered.errors]);\n\t\t\t}\n\t\t\treturn moduleRendered.value;\n\t\t}\n\t\tif (part.type === \"content\" || part.type === \"tag\") {\n\t\t\treturn part.value;\n\t\t}\n\t\tthrowUnimplementedTagType(part);\n\t});\n\treturn { errors: errors, parts: parts };\n}\n\nmodule.exports = render;\n\n//# sourceURL=webpack://docxtemplater/./es6/render.js?");

/***/ }),

/***/ "./es6/resolve.js":
/*!************************!*\
  !*** ./es6/resolve.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction moduleResolve(part, options) {\n\tvar moduleResolved = void 0;\n\tfor (var i = 0, l = options.modules.length; i < l; i++) {\n\t\tvar _module = options.modules[i];\n\t\tmoduleResolved = _module.resolve(part, options);\n\t\tif (moduleResolved) {\n\t\t\treturn moduleResolved;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction resolve(options) {\n\tvar resolved = [];\n\tvar baseNullGetter = options.baseNullGetter;\n\tvar compiled = options.compiled,\n\t    scopeManager = options.scopeManager;\n\n\toptions.nullGetter = function (part, sm) {\n\t\treturn baseNullGetter(part, sm || scopeManager);\n\t};\n\toptions.resolved = resolved;\n\tvar errors = [];\n\treturn Promise.all(compiled.map(function (part) {\n\t\tvar moduleResolved = moduleResolve(part, options);\n\t\tif (moduleResolved) {\n\t\t\treturn moduleResolved.then(function (value) {\n\t\t\t\tresolved.push({ tag: part.value, value: value });\n\t\t\t});\n\t\t}\n\t\tif (part.type === \"placeholder\") {\n\t\t\treturn scopeManager.getValueAsync(part.value, { part: part }).then(function (value) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = options.nullGetter(part);\n\t\t\t\t}\n\t\t\t\tresolved.push({ tag: part.value, value: value });\n\t\t\t\treturn value;\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}).filter(function (a) {\n\t\treturn a;\n\t})).then(function () {\n\t\treturn { errors: errors, resolved: resolved };\n\t});\n}\n\nmodule.exports = resolve;\n\n//# sourceURL=webpack://docxtemplater/./es6/resolve.js?");

/***/ }),

/***/ "./es6/scope-manager.js":
/*!******************************!*\
  !*** ./es6/scope-manager.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    getScopeParserExecutionError = _require.getScopeParserExecutionError;\n\nfunction find(list, fn) {\n\tvar length = list.length >>> 0;\n\tvar value = void 0;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvalue = list[i];\n\t\tif (fn.call(this, value, i, list)) {\n\t\t\treturn value;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nfunction _getValue(tag, meta, num) {\n\tvar _this = this;\n\n\tthis.num = num;\n\tvar scope = this.scopeList[this.num];\n\tif (this.resolved) {\n\t\tvar w = this.resolved;\n\t\tthis.scopePath.forEach(function (p, index) {\n\t\t\tw = find(w, function (r) {\n\t\t\t\treturn r.tag === p;\n\t\t\t});\n\t\t\tw = w.value[_this.scopePathItem[index]];\n\t\t});\n\t\treturn find(w, function (r) {\n\t\t\treturn r.tag === tag;\n\t\t}).value;\n\t}\n\t// search in the scopes (in reverse order) and keep the first defined value\n\tvar result = void 0;\n\tvar parser = this.parser(tag, { scopePath: this.scopePath });\n\ttry {\n\t\tresult = parser.get(scope, this.getContext(meta));\n\t} catch (error) {\n\t\tthrow getScopeParserExecutionError({ tag: tag, scope: scope, error: error });\n\t}\n\tif (result == null && this.num > 0) {\n\t\treturn _getValue.call(this, tag, meta, this.num - 1);\n\t}\n\treturn result;\n}\nfunction _getValueAsync(tag, meta, num) {\n\tvar _this2 = this;\n\n\tthis.num = num;\n\tvar scope = this.scopeList[this.num];\n\t// search in the scopes (in reverse order) and keep the first defined value\n\tvar parser = this.parser(tag, { scopePath: this.scopePath });\n\treturn Promise.resolve(parser.get(scope, this.getContext(meta))).catch(function (error) {\n\t\tthrow getScopeParserExecutionError({ tag: tag, scope: scope, error: error });\n\t}).then(function (result) {\n\t\tif (result == null && _this2.num > 0) {\n\t\t\treturn _getValueAsync.call(_this2, tag, meta, _this2.num - 1);\n\t\t}\n\t\treturn result;\n\t});\n}\n\n// This class responsibility is to manage the scope\nvar ScopeManager = function () {\n\tfunction ScopeManager(options) {\n\t\t_classCallCheck(this, ScopeManager);\n\n\t\tthis.scopePath = options.scopePath;\n\t\tthis.scopePathItem = options.scopePathItem;\n\t\tthis.scopeList = options.scopeList;\n\t\tthis.parser = options.parser;\n\t\tthis.resolved = options.resolved;\n\t}\n\n\t_createClass(ScopeManager, [{\n\t\tkey: \"loopOver\",\n\t\tvalue: function loopOver(tag, callback, inverted, meta) {\n\t\t\tinverted = inverted || false;\n\t\t\treturn this.loopOverValue(this.getValue(tag, meta), callback, inverted);\n\t\t}\n\t}, {\n\t\tkey: \"functorIfInverted\",\n\t\tvalue: function functorIfInverted(inverted, functor, value, i) {\n\t\t\tif (inverted) {\n\t\t\t\tfunctor(value, i);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"isValueFalsy\",\n\t\tvalue: function isValueFalsy(value, type) {\n\t\t\treturn value == null || !value || type === \"[object Array]\" && value.length === 0;\n\t\t}\n\t}, {\n\t\tkey: \"loopOverValue\",\n\t\tvalue: function loopOverValue(value, functor, inverted) {\n\t\t\tvar type = Object.prototype.toString.call(value);\n\t\t\tvar currentValue = this.scopeList[this.num];\n\t\t\tif (this.isValueFalsy(value, type)) {\n\t\t\t\treturn this.functorIfInverted(inverted, functor, currentValue, 0);\n\t\t\t}\n\t\t\tif (type === \"[object Array]\") {\n\t\t\t\tfor (var i = 0, scope; i < value.length; i++) {\n\t\t\t\t\tscope = value[i];\n\t\t\t\t\tthis.functorIfInverted(!inverted, functor, scope, i);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (type === \"[object Object]\") {\n\t\t\t\treturn this.functorIfInverted(!inverted, functor, value, 0);\n\t\t\t}\n\t\t\treturn this.functorIfInverted(!inverted, functor, currentValue, 0);\n\t\t}\n\t}, {\n\t\tkey: \"getValue\",\n\t\tvalue: function getValue(tag, meta) {\n\t\t\tvar num = this.scopeList.length - 1;\n\t\t\treturn _getValue.call(this, tag, meta, num);\n\t\t}\n\t}, {\n\t\tkey: \"getValueAsync\",\n\t\tvalue: function getValueAsync(tag, meta) {\n\t\t\tvar num = this.scopeList.length - 1;\n\t\t\treturn _getValueAsync.call(this, tag, meta, num);\n\t\t}\n\t}, {\n\t\tkey: \"getContext\",\n\t\tvalue: function getContext(meta) {\n\t\t\treturn {\n\t\t\t\tnum: this.num,\n\t\t\t\tmeta: meta,\n\t\t\t\tscopeList: this.scopeList,\n\t\t\t\tresolved: this.resolved,\n\t\t\t\tscopePath: this.scopePath,\n\t\t\t\tscopePathItem: this.scopePathItem\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"createSubScopeManager\",\n\t\tvalue: function createSubScopeManager(scope, tag, i) {\n\t\t\treturn new ScopeManager({\n\t\t\t\tresolved: this.resolved,\n\t\t\t\tparser: this.parser,\n\t\t\t\tscopeList: this.scopeList.concat(scope),\n\t\t\t\tscopePath: this.scopePath.concat(tag),\n\t\t\t\tscopePathItem: this.scopePathItem.concat(i)\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn ScopeManager;\n}();\n\nmodule.exports = function (options) {\n\toptions.scopePath = [];\n\toptions.scopePathItem = [];\n\toptions.scopeList = [options.tags];\n\treturn new ScopeManager(options);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/scope-manager.js?");

/***/ }),

/***/ "./es6/traits.js":
/*!***********************!*\
  !*** ./es6/traits.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    getRight = _require.getRight,\n    getLeft = _require.getLeft,\n    concatArrays = _require.concatArrays,\n    chunkBy = _require.chunkBy,\n    isTagStart = _require.isTagStart,\n    isTagEnd = _require.isTagEnd,\n    isContent = _require.isContent,\n    last = _require.last;\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    XTTemplateError = _require2.XTTemplateError,\n    throwRawTagNotInParagraph = _require2.throwRawTagNotInParagraph,\n    getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\n\nfunction lastTagIsOpenTag(array, tag) {\n\tif (array.length === 0) {\n\t\treturn false;\n\t}\n\tvar lastTag = array[array.length - 1];\n\tvar innerLastTag = lastTag.tag.substr(1);\n\tvar innerCurrentTag = tag.substr(2, tag.length - 3);\n\treturn innerLastTag.indexOf(innerCurrentTag) === 0;\n}\n\nfunction addTag(array, tag) {\n\tarray.push({ tag: tag });\n\treturn array;\n}\n\nfunction getListXmlElements(parts) {\n\t/*\n get the different closing and opening tags between two texts (doesn't take into account tags that are opened then closed (those that are closed then opened are returned)):\n returns:[{\"tag\":\"</w:r>\",\"offset\":13},{\"tag\":\"</w:p>\",\"offset\":265},{\"tag\":\"</w:tc>\",\"offset\":271},{\"tag\":\"<w:tc>\",\"offset\":828},{\"tag\":\"<w:p>\",\"offset\":883},{\"tag\":\"<w:r>\",\"offset\":1483}]\n */\n\tvar tags = parts.filter(function (part) {\n\t\treturn part.type === \"tag\";\n\t});\n\n\tvar result = [];\n\n\tfor (var i = 0, tag; i < tags.length; i++) {\n\t\ttag = tags[i].value;\n\t\t// closing tag\n\t\tif (tag[1] === \"/\") {\n\t\t\tif (lastTagIsOpenTag(result, tag)) {\n\t\t\t\tresult.pop();\n\t\t\t} else {\n\t\t\t\tresult = addTag(result, tag);\n\t\t\t}\n\t\t} else if (tag[tag.length - 2] !== \"/\") {\n\t\t\tresult = addTag(result, tag);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction has(name, xmlElements) {\n\tfor (var i = 0; i < xmlElements.length; i++) {\n\t\tvar xmlElement = xmlElements[i];\n\t\tif (xmlElement.tag.indexOf(\"<\" + name) === 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n\tvar parts = postparsed.slice(pair[0].offset, pair[1].offset);\n\tvar xmlElements = getListXmlElements(parts);\n\tvar closingTagCount = xmlElements.filter(function (xmlElement) {\n\t\treturn xmlElement.tag[1] === \"/\";\n\t}).length;\n\tvar startingTagCount = xmlElements.filter(function (xmlElement) {\n\t\tvar tag = xmlElement.tag;\n\n\t\treturn tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n\t}).length;\n\tif (closingTagCount !== startingTagCount) {\n\t\treturn {\n\t\t\terror: getLoopPositionProducesInvalidXMLError({\n\t\t\t\ttag: pair[0].part.value\n\t\t\t})\n\t\t};\n\t}\n\n\tvar _loop = function _loop(i, len) {\n\t\tvar _expandTags$i = expandTags[i],\n\t\t    contains = _expandTags$i.contains,\n\t\t    expand = _expandTags$i.expand,\n\t\t    onlyTextInTag = _expandTags$i.onlyTextInTag;\n\n\t\tif (has(contains, xmlElements)) {\n\t\t\tif (onlyTextInTag) {\n\t\t\t\tvar left = getLeft(postparsed, contains, pair[0].offset);\n\t\t\t\tvar right = getRight(postparsed, contains, pair[1].offset);\n\n\t\t\t\tvar chunks = chunkBy(postparsed.slice(left, right), function (p) {\n\t\t\t\t\tif (isTagStart(contains, p)) {\n\t\t\t\t\t\treturn \"start\";\n\t\t\t\t\t}\n\t\t\t\t\tif (isTagEnd(contains, p)) {\n\t\t\t\t\t\treturn \"end\";\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\n\t\t\t\tif (chunks.length <= 2) {\n\t\t\t\t\treturn \"continue\";\n\t\t\t\t}\n\n\t\t\t\tvar firstChunk = chunks[0];\n\t\t\t\tvar lastChunk = last(chunks);\n\n\t\t\t\tvar firstContent = firstChunk.filter(isContent);\n\t\t\t\tvar lastContent = lastChunk.filter(isContent);\n\t\t\t\tif (firstContent.length !== 1 || lastContent.length !== 1) {\n\t\t\t\t\treturn \"continue\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tv: { value: expand }\n\t\t\t};\n\t\t}\n\t};\n\n\tfor (var i = 0, len = expandTags.length; i < len; i++) {\n\t\tvar _ret = _loop(i, len);\n\n\t\tswitch (_ret) {\n\t\t\tcase \"continue\":\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tif ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction expandOne(part, postparsed, options) {\n\tvar expandTo = part.expandTo || options.expandTo;\n\tvar index = postparsed.indexOf(part);\n\tif (!expandTo) {\n\t\treturn postparsed;\n\t}\n\tvar right = void 0,\n\t    left = void 0;\n\ttry {\n\t\tright = getRight(postparsed, expandTo, index);\n\t\tleft = getLeft(postparsed, expandTo, index);\n\t} catch (rootError) {\n\t\tif (rootError instanceof XTTemplateError) {\n\t\t\tthrowRawTagNotInParagraph({\n\t\t\t\tpart: part,\n\t\t\t\trootError: rootError,\n\t\t\t\tpostparsed: postparsed,\n\t\t\t\texpandTo: expandTo,\n\t\t\t\tindex: index\n\t\t\t});\n\t\t}\n\t\tthrow rootError;\n\t}\n\tvar leftParts = postparsed.slice(left, index);\n\tvar rightParts = postparsed.slice(index + 1, right + 1);\n\tvar inner = options.getInner({\n\t\tindex: index,\n\t\tpart: part,\n\t\tleftParts: leftParts,\n\t\trightParts: rightParts,\n\t\tleft: left,\n\t\tright: right,\n\t\tpostparsed: postparsed\n\t});\n\tif (!inner.length) {\n\t\tinner.expanded = [leftParts, rightParts];\n\t\tinner = [inner];\n\t}\n\treturn concatArrays([postparsed.slice(0, left), inner, postparsed.slice(right + 1)]);\n}\n\nfunction expandToOne(postparsed, options) {\n\tvar errors = [];\n\tif (postparsed.errors) {\n\t\terrors = postparsed.errors;\n\t\tpostparsed = postparsed.postparsed;\n\t}\n\tvar expandToElements = postparsed.reduce(function (elements, part) {\n\t\tif (part.type === \"placeholder\" && part.module === options.moduleName) {\n\t\t\telements.push(part);\n\t\t}\n\t\treturn elements;\n\t}, []);\n\n\texpandToElements.forEach(function (part) {\n\t\ttry {\n\t\t\tpostparsed = expandOne(part, postparsed, options);\n\t\t} catch (error) {\n\t\t\tif (error instanceof XTTemplateError) {\n\t\t\t\terrors.push(error);\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t});\n\treturn { postparsed: postparsed, errors: errors };\n}\n\nmodule.exports = {\n\texpandToOne: expandToOne,\n\tgetExpandToDefault: getExpandToDefault\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/traits.js?");

/***/ }),

/***/ "./es6/xml-matcher.js":
/*!****************************!*\
  !*** ./es6/xml-matcher.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// res class responsibility is to parse the XML.\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    pregMatchAll = _require.pregMatchAll;\n\nfunction handleRecursiveCase(res) {\n\t/*\n * Because xmlTemplater is recursive (meaning it can call it self), we need to handle special cases where the XML is not valid:\n * For example with res string \"I am</w:t></w:r></w:p><w:p><w:r><w:t>sleeping\",\n *   - we need to match also the string that is inside an implicit <w:t> (that's the role of replacerUnshift) (in res case 'I am')\n *   - we need to match the string that is at the right of a <w:t> (that's the role of replacerPush) (in res case 'sleeping')\n * the test: describe \"scope calculation\" it \"should compute the scope between 2 <w:t>\" makes sure that res part of code works\n * It should even work if they is no XML at all, for example if the code is just \"I am sleeping\", in res case however, they should only be one match\n */\n\n\tfunction replacerUnshift() {\n\t\tvar pn = { array: Array.prototype.slice.call(arguments) };\n\t\tpn.array.shift();\n\t\tvar match = pn.array[0] + pn.array[1];\n\t\t// add match so that pn[0] = whole match, pn[1]= first parenthesis,...\n\t\tpn.array.unshift(match);\n\t\tpn.array.pop();\n\t\tvar offset = pn.array.pop();\n\t\tpn.offset = offset;\n\t\tpn.first = true;\n\t\t// add at the beginning\n\t\tres.matches.unshift(pn);\n\t}\n\n\tif (res.content.indexOf(\"<\") === -1 && res.content.indexOf(\">\") === -1) {\n\t\tres.content.replace(/^()([^<>]*)$/, replacerUnshift);\n\t}\n\n\tvar r = new RegExp(\"^()([^<]+)</(?:\" + res.tagsXmlArrayJoined + \")>\");\n\tres.content.replace(r, replacerUnshift);\n\n\tfunction replacerPush() {\n\t\tvar pn = { array: Array.prototype.slice.call(arguments) };\n\t\tpn.array.pop();\n\t\tvar offset = pn.array.pop();\n\t\tpn.offset = offset;\n\t\tpn.last = true;\n\t\tif (pn.array[0].indexOf(\"/>\") !== -1) {\n\t\t\treturn;\n\t\t}\n\t\t// add at the end\n\t\tres.matches.push(pn);\n\t}\n\n\tr = new RegExp(\"(<(?:\" + res.tagsXmlArrayJoined + \")[^>]*>)([^>]+)$\");\n\tres.content.replace(r, replacerPush);\n\treturn res;\n}\n\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n\tvar res = {};\n\tres.content = content;\n\tres.tagsXmlArray = tagsXmlArray;\n\tres.tagsXmlArrayJoined = res.tagsXmlArray.join(\"|\");\n\tvar regexp = new RegExp(\"(?:(<(?:\" + res.tagsXmlArrayJoined + \")[^>]*>)([^<>]*)</(?:\" + res.tagsXmlArrayJoined + \")>)|(<(?:\" + res.tagsXmlArrayJoined + \")[^>]*/>)\", \"g\");\n\tres.matches = pregMatchAll(regexp, res.content);\n\treturn handleRecursiveCase(res);\n};\n\n//# sourceURL=webpack://docxtemplater/./es6/xml-matcher.js?");

/***/ }),

/***/ "./es6/xml-templater.js":
/*!******************************!*\
  !*** ./es6/xml-templater.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = __webpack_require__(/*! ./doc-utils */ \"./es6/doc-utils.js\"),\n    wordToUtf8 = _require.wordToUtf8,\n    convertSpaces = _require.convertSpaces,\n    defaults = _require.defaults;\n\nvar createScope = __webpack_require__(/*! ./scope-manager */ \"./es6/scope-manager.js\");\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher */ \"./es6/xml-matcher.js\");\n\nvar _require2 = __webpack_require__(/*! ./errors */ \"./es6/errors.js\"),\n    throwMultiError = _require2.throwMultiError,\n    throwContentMustBeString = _require2.throwContentMustBeString;\n\nvar Lexer = __webpack_require__(/*! ./lexer */ \"./es6/lexer.js\");\nvar Parser = __webpack_require__(/*! ./parser.js */ \"./es6/parser.js\");\nvar _render = __webpack_require__(/*! ./render.js */ \"./es6/render.js\");\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"./es6/postrender.js\");\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"./es6/resolve.js\");\n\nfunction _getFullText(content, tagsXmlArray) {\n\tvar matcher = xmlMatcher(content, tagsXmlArray);\n\tvar result = matcher.matches.map(function (match) {\n\t\treturn match.array[2];\n\t});\n\treturn wordToUtf8(convertSpaces(result.join(\"\")));\n}\n\nmodule.exports = function () {\n\tfunction XmlTemplater(content, options) {\n\t\t_classCallCheck(this, XmlTemplater);\n\n\t\tthis.filePath = options.filePath;\n\t\tthis.modules = options.modules;\n\t\tthis.fileTypeConfig = options.fileTypeConfig;\n\t\tObject.keys(defaults).map(function (key) {\n\t\t\tthis[key] = options[key] != null ? options[key] : defaults[key];\n\t\t}, this);\n\t\tthis.setModules({ inspect: { filePath: this.filePath } });\n\t\tthis.load(content);\n\t}\n\n\t_createClass(XmlTemplater, [{\n\t\tkey: \"load\",\n\t\tvalue: function load(content) {\n\t\t\tif (typeof content !== \"string\") {\n\t\t\t\tthrowContentMustBeString(typeof content === \"undefined\" ? \"undefined\" : _typeof(content));\n\t\t\t}\n\t\t\tthis.content = content;\n\t\t}\n\t}, {\n\t\tkey: \"setTags\",\n\t\tvalue: function setTags(tags) {\n\t\t\tthis.tags = tags != null ? tags : {};\n\t\t\tthis.scopeManager = createScope({ tags: this.tags, parser: this.parser });\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"resolveTags\",\n\t\tvalue: function resolveTags(tags) {\n\t\t\tvar _this = this;\n\n\t\t\tthis.tags = tags != null ? tags : {};\n\t\t\tthis.scopeManager = createScope({ tags: this.tags, parser: this.parser });\n\t\t\tvar options = this.getOptions();\n\t\t\toptions.scopeManager = createScope(options);\n\t\t\toptions.resolve = resolve;\n\t\t\treturn resolve(options).then(function (_ref) {\n\t\t\t\tvar resolved = _ref.resolved;\n\n\t\t\t\treturn Promise.all(resolved.map(function (r) {\n\t\t\t\t\treturn Promise.resolve(r);\n\t\t\t\t})).then(function (resolved) {\n\t\t\t\t\treturn _this.resolved = resolved;\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"getFullText\",\n\t\tvalue: function getFullText() {\n\t\t\treturn _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n\t\t}\n\t}, {\n\t\tkey: \"setModules\",\n\t\tvalue: function setModules(obj) {\n\t\t\tthis.modules.forEach(function (module) {\n\t\t\t\tmodule.set(obj);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"parse\",\n\t\tvalue: function parse() {\n\t\t\tvar allErrors = [];\n\t\t\tthis.xmllexed = Lexer.xmlparse(this.content, {\n\t\t\t\ttext: this.fileTypeConfig.tagsXmlTextArray,\n\t\t\t\tother: this.fileTypeConfig.tagsXmlLexedArray\n\t\t\t});\n\t\t\tthis.setModules({ inspect: { xmllexed: this.xmllexed } });\n\n\t\t\tvar _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters),\n\t\t\t    lexed = _Lexer$parse.lexed,\n\t\t\t    lexerErrors = _Lexer$parse.errors;\n\n\t\t\tallErrors = allErrors.concat(lexerErrors);\n\t\t\tthis.lexed = lexed;\n\t\t\tthis.setModules({ inspect: { lexed: this.lexed } });\n\t\t\tthis.parsed = Parser.parse(this.lexed, this.modules);\n\t\t\tthis.setModules({ inspect: { parsed: this.parsed } });\n\n\t\t\tvar _Parser$postparse = Parser.postparse(this.parsed, this.modules),\n\t\t\t    postparsed = _Parser$postparse.postparsed,\n\t\t\t    postparsedErrors = _Parser$postparse.errors;\n\n\t\t\tthis.postparsed = postparsed;\n\t\t\tthis.setModules({ inspect: { postparsed: this.postparsed } });\n\t\t\tallErrors = allErrors.concat(postparsedErrors);\n\t\t\tthis.errorChecker(allErrors);\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"errorChecker\",\n\t\tvalue: function errorChecker(errors) {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (errors.length) {\n\t\t\t\tthis.modules.forEach(function (module) {\n\t\t\t\t\terrors = module.errorsTransformer(errors);\n\t\t\t\t});\n\t\t\t\terrors.forEach(function (error) {\n\t\t\t\t\terror.properties.file = _this2.filePath;\n\t\t\t\t});\n\t\t\t\tthrowMultiError(errors);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"baseNullGetter\",\n\t\tvalue: function baseNullGetter(part, sm) {\n\t\t\tvar _this3 = this;\n\n\t\t\tvar value = this.modules.reduce(function (value, module) {\n\t\t\t\tif (value != null) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn module.nullGetter(part, sm, _this3);\n\t\t\t}, null);\n\t\t\tif (value != null) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn this.nullGetter(part, sm);\n\t\t}\n\t}, {\n\t\tkey: \"getOptions\",\n\t\tvalue: function getOptions() {\n\t\t\treturn {\n\t\t\t\tcompiled: this.postparsed,\n\t\t\t\ttags: this.tags,\n\t\t\t\tmodules: this.modules,\n\t\t\t\tparser: this.parser,\n\t\t\t\tbaseNullGetter: this.baseNullGetter.bind(this),\n\t\t\t\tfilePath: this.filePath,\n\t\t\t\tlinebreaks: this.linebreaks\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render(to) {\n\t\t\tthis.filePath = to;\n\t\t\tvar options = this.getOptions();\n\t\t\toptions.resolved = this.resolved;\n\t\t\toptions.scopeManager = createScope(options);\n\t\t\toptions.render = _render;\n\n\t\t\tvar _render2 = _render(options),\n\t\t\t    errors = _render2.errors,\n\t\t\t    parts = _render2.parts;\n\n\t\t\tthis.errorChecker(errors);\n\n\t\t\tthis.content = postrender(parts, options);\n\t\t\tthis.setModules({ inspect: { content: this.content } });\n\t\t\treturn this;\n\t\t}\n\t}]);\n\n\treturn XmlTemplater;\n}();\n\n//# sourceURL=webpack://docxtemplater/./es6/xml-templater.js?");

/***/ })

/******/ });